import winim/lean

template NT_SUCCESS*(s: NTSTATUS): bool = (cast[int](s) >= 0)
template NtCurrentProcess*(): HANDLE = cast[HANDLE](-1)

#[ Objects ]#
type
  NT_SYSCALL* = object
    dwSSn*: uint32
    pSyscallAddress*: PVOID
    pSyscallInstAddress*: PVOID
  PNT_SYSCALL* = ptr NT_SYSCALL
  NTDLL_CONFIG* = object
    uModule*: pointer
    dwNumberOfNames*: DWORD
    pdwArrayOfNames*: ptr UncheckedArray[DWORD]
    pdwArrayOfAddresses*: ptr UncheckedArray[DWORD]
    pwArrayOfOrdinals*: ptr UncheckedArray[WORD]
  PNTDLL_CONFIG* = ptr NTDLL_CONFIG

#[ Global Variables ]#
var 
  wSystemCall*: DWORD
  qSyscallInsAddress*: PVOID
  gNtdllConf*: NTDLL_CONFIG

#[ Constants ]#
const 
  SYSCALL_STUB_SIZE = 0X20  # Size of a syscall stub is 32 bytes
  SEARCH_UP         = (-1 * SYSCALL_STUB_SIZE)
  SEARCH_DOWN       = SYSCALL_STUB_SIZE
  SEARCH_RANGE      = 0xFF


#[ Public Hashing Functions ]#
proc hashStrA*(s: cstring): uint32 {.inline.} =
  var hash: uint32 = 0xff
  for i in s: hash = ((hash shl 5) + hash) + cast[uint32](i)
  return hash

proc hashStrW*(s: PWSTR): uint32  =
  var 
    hash: uint32 = 0xff
    pS = cast[ptr UncheckedArray[WCHAR]](s)
    idx: int = 0
  while pS[idx] != 0:
    hash = ((hash shl 5) + hash) + cast[uint32](pS[idx])
    idx.inc
  return hash

#[ Private Functions ]#
proc getPPEB*(): PPEB {.asmNoStackFrame, inline.}= 
  asm """
    mov rax, qword ptr gs:[0x60]
    ret
  """

proc initNtdllConfigStructure(): bool =
  var pPeb = getPPEB()
  if (cast[int](pPeb) == 0):
    return false
  var 
    pLdr = cast[PLDR_DATA_TABLE_ENTRY](cast[int](pPeb.Ldr.InMemoryOrderModuleList.Flink.Flink) - 0x10)
    uModule = cast[pointer](pLdr.DllBase)
  if cast[int](uModule) == 0:
    return false
  var pImgDosHdr = cast[PIMAGE_DOS_HEADER](uModule)
  if pImgDosHdr.e_magic != IMAGE_DOS_SIGNATURE:
    return false
  var pImgNtHdrs = cast[PIMAGE_NT_HEADERS](cast[int](uModule) + pImgDosHdr.e_lfanew)
  if pImgNtHdrs.Signature != IMAGE_NT_SIGNATURE:
    return false
  var pImgExpDir = cast[PIMAGE_EXPORT_DIRECTORY](cast[int](uModule) + pImgNtHdrs.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress)
  if cast[int](pImgExpDir) == 0:
    return false

  gNtdllConf.uModule = uModule
  gNtdllConf.dwNumberOfNames = pImgExpDir.NumberOfNames
  gNtdllConf.pdwArrayOfNames = cast[ptr UncheckedArray[DWORD]](cast[int](uModule) + pImgExpDir.AddressOfNames)
  gNtdllConf.pdwArrayOfAddresses = cast[ptr UncheckedArray[DWORD]](cast[int](uModule) + pImgExpDir.AddressOfFunctions)
  gNtdllConf.pwArrayOfOrdinals = cast[ptr UncheckedArray[WORD]](cast[int](uModule) + pImgExpDir.AddressOfNameOrdinals)

  return true

#[ Public Functions ]#
proc fetchNtSyscall*(dwSysHash: uint32, pNtSys: PNT_SYSCALL): bool =
  if cast[int](gNtdllConf.uModule) == 0:
    if not initNtdllConfigStructure():
      return false
  
  for i in 0 ..< gNtdllConf.dwNumberOfNames:
    var 
      pcFuncName = cast[PCHAR](cast[int](gNtdllConf.uModule) + cast[int](gNtdllConf.pdwArrayOfNames[i]))
      pFuncAddress = cast[PVOID](cast[int](gNtdllConf.uModule) + cast[int](gNtdllConf.pdwArrayOfAddresses[gNtdllConf.pwArrayOfOrdinals[i]]))

    if hashStrA(cast[cstring](pcFuncName)) == dwSysHash:

      pNtSys.pSyscallAddress = pFuncAddress

      if (cast[PBYTE](cast[int](pFuncAddress))[] == 0x4c) and
              (cast[PBYTE](cast[int](pFuncAddress) + 1)[] == 0x8b) and
              (cast[PBYTE](cast[int](pFuncAddress) + 2)[] == 0xd1) and
              (cast[PBYTE](cast[int](pFuncAddress) + 3)[] == 0xb8) and
              (cast[PBYTE](cast[int](pFuncAddress) + 6)[] == 0x00) and
              (cast[PBYTE](cast[int](pFuncAddress) + 7)[] == 0x00):
        var 
          h = cast[PBYTE](cast[int](pFuncAddress) + 5)[]
          l = cast[PBYTE](cast[int](pFuncAddress) + 4)[]
        pNtSys.dwSSn = ((h shl 8) or l).uint32
        break

      if (cast[PBYTE](pFuncAddress)[] == 0xe9): 
        for idx in 1 .. SEARCH_RANGE:
          if (cast[PBYTE](cast[int](pFuncAddress) + (idx * SEARCH_DOWN) + 0)[] == 0x4c) and
                  (cast[PBYTE](cast[int](pFuncAddress) + (idx * SEARCH_DOWN) + 1)[] == 0x8b) and
                  (cast[PBYTE](cast[int](pFuncAddress) + (idx * SEARCH_DOWN) + 2)[] == 0xd1) and
                  (cast[PBYTE](cast[int](pFuncAddress) + (idx * SEARCH_DOWN) + 3)[] == 0xb8) and
                  (cast[PBYTE](cast[int](pFuncAddress) + (idx * SEARCH_DOWN) + 6)[] == 0x00) and
                  (cast[PBYTE](cast[int](pFuncAddress) + (idx * SEARCH_DOWN) + 7)[] == 0x00):
            var 
              h = cast[PBYTE](cast[int](pFuncAddress) + 5 + (idx * SEARCH_DOWN))[]
              l = cast[PBYTE](cast[int](pFuncAddress) + 4 + (idx * SEARCH_DOWN))[]
            pNtSys.dwSSn = ((h shl 8) or l).uint32
            break
          if (cast[PBYTE](cast[int](pFuncAddress) + (idx * SEARCH_UP) + 0)[] == 0x4c) and
                  (cast[PBYTE](cast[int](pFuncAddress) + (idx * SEARCH_UP) + 1)[] == 0x8b) and
                  (cast[PBYTE](cast[int](pFuncAddress) + (idx * SEARCH_UP) + 2)[] == 0xd1) and
                  (cast[PBYTE](cast[int](pFuncAddress) + (idx * SEARCH_UP) + 3)[] == 0xb8) and
                  (cast[PBYTE](cast[int](pFuncAddress) + (idx * SEARCH_UP) + 6)[] == 0x00) and
                  (cast[PBYTE](cast[int](pFuncAddress) + (idx * SEARCH_UP) + 7)[] == 0x00):
            var 
              h = cast[PBYTE](cast[int](pFuncAddress) + 5 + (idx * SEARCH_UP))[]
              l = cast[PBYTE](cast[int](pFuncAddress) + 4 + (idx * SEARCH_UP))[]
            pNtSys.dwSSn = ((h shl 8) or l).uint32
            break

      if (cast[PBYTE](cast[int](pFuncAddress) + 3)[] == 0xe9): 
        for idx in 1 .. SEARCH_RANGE:
          if (cast[PBYTE](cast[int](pFuncAddress) + (idx * SEARCH_DOWN) + 0)[] == 0x4c) and
                  (cast[PBYTE](cast[int](pFuncAddress) + (idx * SEARCH_DOWN) + 1)[] == 0x8b) and
                  (cast[PBYTE](cast[int](pFuncAddress) + (idx * SEARCH_DOWN) + 2)[] == 0xd1) and
                  (cast[PBYTE](cast[int](pFuncAddress) + (idx * SEARCH_DOWN) + 3)[] == 0xb8) and
                  (cast[PBYTE](cast[int](pFuncAddress) + (idx * SEARCH_DOWN) + 6)[] == 0x00) and
                  (cast[PBYTE](cast[int](pFuncAddress) + (idx * SEARCH_DOWN) + 7)[] == 0x00):
            var 
              h = cast[PBYTE](cast[int](pFuncAddress) + 5 + (idx * SEARCH_DOWN))[]
              l = cast[PBYTE](cast[int](pFuncAddress) + 4 + (idx * SEARCH_DOWN))[]
            pNtSys.dwSSn = ((h shl 8) or l).uint32
            break
          if (cast[PBYTE](cast[int](pFuncAddress) + (idx * SEARCH_UP) + 0)[] == 0x4c) and
                  (cast[PBYTE](cast[int](pFuncAddress) + (idx * SEARCH_UP) + 1)[] == 0x8b) and
                  (cast[PBYTE](cast[int](pFuncAddress) + (idx * SEARCH_UP) + 2)[] == 0xd1) and
                  (cast[PBYTE](cast[int](pFuncAddress) + (idx * SEARCH_UP) + 3)[] == 0xb8) and
                  (cast[PBYTE](cast[int](pFuncAddress) + (idx * SEARCH_UP) + 6)[] == 0x00) and
                  (cast[PBYTE](cast[int](pFuncAddress) + (idx * SEARCH_UP) + 7)[] == 0x00):
            var 
              h = cast[PBYTE](cast[int](pFuncAddress) + 5 + (idx * SEARCH_UP))[]
              l = cast[PBYTE](cast[int](pFuncAddress) + 4 + (idx * SEARCH_UP))[]
            pNtSys.dwSSn = ((h shl 8) or l).uint32
            break
      break
  
  if (cast[int](pNtSys.pSyscallAddress) == 0) or (cast[int](pNtSys.dwSSn) == 0):
    return false

  # Get random syscall instruction address
  var 
    uSyscallInstAddress = cast[int](pNtSys.pSyscallAddress) + (GetTickCount64() mod 0xFF)
    z = 0
    x = 1
  
  while (z <= SEARCH_RANGE):
    if (cast[PBYTE](uSyscallInstAddress + z)[]  == 0x0F) and (cast[PBYTE](uSyscallInstAddress + x)[] == 0x05):
      pNtSys.pSyscallInstAddress = cast[PVOID](uSyscallInstAddress + z)
      return true
    z.inc; x.inc

  return false

#[ Syscall stubs ]#
proc SetSSn*(dwSSn: uint32, pSysAddr: PVOID) {.asmNoStackFrame.} =
  asm """
    xor rax, rax
    mov `wSystemCall`, eax
    mov `qSyscallInsAddress`, rax
    mov eax, ecx
    mov `wSystemCall`, eax
    mov r9, rdx
    mov `qSyscallInsAddress`, r9
    ret
  """

template SET_SYSCALL*(ntSys: NT_SYSCALL) = SetSSn(ntSys.dwSSn, ntSys.pSyscallInstAddress)

proc RunSyscall*(arg1: auto): NTSTATUS {.asmNoStackFrame, varargs.} =
  asm """
    xor r10, r10
    mov rax, rcx
    mov r10, rax
    mov eax, `wSystemCall`
    jmp $+11
    xor eax, eax
    xor rcx, rcx
    shl r10, 2
    jmp qword ptr [`qSyscallInsAddress`]
    xor r10, r10
    mov `qSyscallInsAddress`, r10
    ret
  """
