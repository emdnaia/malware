import winim

import memcmp

proc getProcAddressReplacement*(hModule: HMODULE, lpApiName: cstring): FARPROC {.inline, noSideEffect.} =
  let
    pBase = cast[int](hModule)
    pImgDosHdr = cast[PIMAGE_DOS_HEADER](pBase)
    pImgNtHdrs = cast[PIMAGE_NT_HEADERS](cast[int](pBase) + pImgDosHdr.e_lfanew)

  if (pImgDosHdr.e_magic != IMAGE_DOS_SIGNATURE) or (pImgNtHdrs.Signature != IMAGE_NT_SIGNATURE):
    return cast[FARPROC](0)
  
  let
    imgOptHdr: IMAGE_OPTIONAL_HEADER = cast[IMAGE_OPTIONAL_HEADER](pImgNtHdrs.OptionalHeader)
    pImgExportDir: PIMAGE_EXPORT_DIRECTORY = cast[PIMAGE_EXPORT_DIRECTORY](cast[DWORD64](pBase) + cast[DWORD64](imgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress))
    functionNameArray: ptr UncheckedArray[DWORD] = cast[ptr UncheckedArray[DWORD]](cast[ByteAddress](pBase) + pImgExportDir.AddressOfNames)
    functionAddressArray:  ptr UncheckedArray[DWORD] = cast[ptr UncheckedArray[DWORD]](cast[ByteAddress](pBase) + pImgExportDir.AddressOfFunctions)
    functionOrdinalArray: ptr UncheckedArray[WORD] = cast[ptr UncheckedArray[WORD]](cast[ByteAddress](pBase) + pImgExportDir.AddressOfNameOrdinals)

  var i: DWORD = 0
  while i < pImgExportDir.NumberOfFunctions:
    var 
      pFunctionName: PCHAR = (cast[PCHAR](cast[ByteAddress](pBase) + functionNameArray[i]))
      pFunctionAddress: PVOID = cast[PVOID](cast[ByteAddress](pBase) + functionAddressArray[functionOrdinalArray[i]])
    if memcmp(cast[uint](pFunctionName), cast[uint](lpApiName), lpApiname.len, 1) == 0:
      return cast[FARPROC](pFunctionAddress)
    i.inc
  return cast[FARPROC](NULL)