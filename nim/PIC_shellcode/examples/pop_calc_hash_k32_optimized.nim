#[ size of shellcode generated is 267, optimization includes no exit and optimized kernel32 ]#
import utils/[getmoduleh, getprocaddr, hash]
import winim

# declaring WinExec
type WinExec = (proc(lpCmdLine: LPCSTR, uCmdShow: UINT): int32 {.stdcall.})
type ExitProcess = (proc(uExitCode: UINT): void {.stdcall.})

proc main() {.asmNoStackFrame, inline, noreturn.} =
  asm """
    and rsp, 0xfffffffffffffff0
    mov rbp, rsp
    # since no stack frame is generated from main, we manage the stack size
    sub rsp, 0x100    # allocate stack space, arbitrary size ... depends on payload
  """

  var sCalcExe {.stackStringA.} = "calc.exe"

  const 
    hashWinExec = hashStringDjb2A("WinExec".cstring)
    # hashExitProcess = hashStringDjb2A("ExitProcess".cstring)

  var
    # h: HMODULE = getModuleHandle(cast[cstring](addr sKernel32[0]))
    h: HMODULE = locateKernel32() 
    pWinExec: WinExec = cast[WinExec](getProcAddressHash(h, hashWinExec))
    # pExitProcess: ExitProcess = cast[ExitProcess](getProcAddressHash(h, hashExitProcess))

  discard pWinExec(cast[LPCSTR](addr sCalcExe[0]), cast[UINT](0))
  # pExitProcess(0)


when isMainModule:
  main()