import utils/[getmoduleh, getprocaddr, stack]
import winim

# declaring WinExec
type  WinExec = (proc(lpCmdLine: LPCSTR, uCmdShow: UINT): int32 {.stdcall.})
type ExitProcess = (proc(uExitCode: UINT): void {.stdcall.})

{.push stackTrace:off.}
proc main() {.asmNoStackFrame, inline, noreturn.} =
  asm """
    and rsp, 0xfffffffffffffff0
    mov rbp, rsp
    # since no stack frame is generated from main, we manage the stack size
    sub rsp, 0x600    # allocate stack space, arbitrary size ... depends on payload
  """

  var sKernel32: array[13, char] 
  sKernel32[0] = 'K'
  sKernel32[1] = 'E'
  sKernel32[2] = 'R'
  sKernel32[3] = 'N'
  sKernel32[4] = 'E'
  sKernel32[5] = 'L'
  sKernel32[6] = '3'
  sKernel32[7] = '2'
  sKernel32[8] = '.'
  sKernel32[9] = 'd'
  sKernel32[10] = 'l'
  sKernel32[11] = 'l'
  sKernel32[12] = '\0'

  var sWinExec: array[8, char]
  sWinExec[0] = 'W'
  sWinExec[1] = 'i'
  sWinExec[2] = 'n'
  sWinExec[3] = 'E'
  sWinExec[4] = 'x'
  sWinExec[5] = 'e'
  sWinExec[6] = 'c'
  sWinExec[7] = '\0'

  var sCalcExe: array[9, char]
  sCalcExe[0] = 'c'
  sCalcExe[1] = 'a'
  sCalcExe[2] = 'l'
  sCalcExe[3] = 'c'
  sCalcExe[4] = '.'
  sCalcExe[5] = 'e'
  sCalcExe[6] = 'x'
  sCalcExe[7] = 'e'
  sCalcExe[8] = '\0'

  var sExitProcess: array[12, char]
  sExitProcess[0] = 'E'
  sExitProcess[1] = 'x'
  sExitProcess[2] = 'i'
  sExitProcess[3] = 't'
  sExitProcess[4] = 'P'
  sExitProcess[5] = 'r'
  sExitProcess[6] = 'o'
  sExitProcess[7] = 'c'
  sExitProcess[8] = 'e'
  sExitProcess[9] = 's'
  sExitProcess[10] = 's'
  sExitProcess[11] = '\0'

  var
    h: HMODULE = getModuleHandleReplacement(cast[cstring](addr sKernel32[0]))
    pWinExec: WinExec = cast[WinExec](getProcAddressReplacement(h, cast[cstring](addr sWinExec[0])))
    pExitProcess: ExitProcess = cast[ExitProcess](getProcAddressReplacement(h, cast[cstring](addr sExitProcess[0])))

  discard pWinExec(cast[LPCSTR](addr sCalcExe[0]), cast[UINT](0))
  pExitProcess(0)

{.pop.}

when isMainModule:
  main()